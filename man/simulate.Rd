% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate.R
\name{simulate}
\alias{simulate}
\alias{simulate.dynamics}
\alias{is.simulation}
\alias{is.simulation_list}
\alias{print.simulation}
\alias{print.simulation_list}
\alias{plot.simulation}
\alias{plot.simulation_list}
\title{Simulate single or multispecies population dynamics in R}
\usage{
\method{simulate}{dynamics}(
  object,
  nsim = 1,
  seed = NULL,
  init = NULL,
  options = list(),
  args = list(),
  args.dyn = NULL,
  args.fn = NULL
)

is.simulation(x)

is.simulation_list(x)

\method{print}{simulation}(x, ...)

\method{print}{simulation_list}(x, ...)

\method{plot}{simulation}(x, y, ..., class = NULL)

\method{plot}{simulation_list}(x, y, ..., which = seq_along(x))
}
\arguments{
\item{object}{a \code{dynamics} object created with
\code{\link{dynamics}} or from a subsequent call to
\code{\link{multispecies}} or \code{\link{metapopulation}}}

\item{nsim}{the number of replicate simulations (default = 1)}

\item{seed}{optional seed used prior to initialisation and simulation to
give reproducible results}

\item{init}{an array of initial conditions with one row per replicate and one
column per population stage. Additionally requires one slice per species if
\code{obj} has been created with \code{\link{multispecies}}. Defaults
to \code{NULL}, in which case initial conditions are generated randomly
according to \code{options()$aae.pop_initialisation}}

\item{options}{a named \code{list} of simulation options. Currently accepted
values are:
- \code{ntime} the number of time steps to simulate, ignored if \code{obj}
    includes a \code{\link{covariates}} (default = 50)
- \code{keep_slices} \code{logical} defining whether to keep intermediate
    population abundances or (if \code{FALSE}) to return only the final
    time slice
- \code{tidy_abundances} a function to handle predicted abundance data
    that may be non-integer. Defaults to \code{identity}; suggested
    alternatives are \code{floor}, \code{round}, or \code{ceiling}
- \code{initialise_args} a list of arguments passed to the function
    used to initialise abundance trajectories. Only used if
    \code{init = NULL}. Defaults to \code{options()$aae.pop_lambda},
    which specifies lambda for Poisson random draws. The default
    initialisation function is defined by
    \code{options()$aae.pop_initialisation}.}

\item{args}{named list of lists passing arguments to processes defined
in \code{object}, including \code{interaction} for
\code{\link{multispecies}} objects.}

\item{args.dyn}{list of time-varying values of \code{args}. Defaults to
\code{NULL} and requires one element for each generation (specified
by covariates or with \code{options$ntime}).}

\item{args.fn}{named list of functions evaluating additional values of
\code{args} based on the matrix and abundances in each generation.
Defaults to \code{NULL}.}

\item{x}{a simulation or simulation_list object}

\item{\dots}{Additional arguments passed to plot}

\item{y}{ignored; included for consistency with plot method}

\item{class}{integer value specifying which age/stage class to plot.
Defaults to NULL, in which case the sum of all classes is plotted}

\item{which}{integer value or vector of integer values specifying
which species to plot. Defaults to one plot for each species}
}
\description{
Simulate population dynamics for one or more
  species defined by \code{\link{dynamics}} objects.
}
\details{
To be completed.

Basic plot methods are provided for \code{simulation} and
  \code{simulation_list} classes. Plots can present a single class
  or the sum of all classes, and can include one or more species
  for \code{simulation_list} objects. \code{\dots} can be used to
  pass additional arguments to \code{\link[graphics]{plot}} and
  \code{\link[graphics]{lines}}.
}
\examples{

# define a population matrix (columns move to rows)
nstage <- 5
popmat <- matrix(0, nrow = nstage, ncol = nstage)
popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20)
popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)

# can extract standard population matrix summary stats
lambda <- Re(eigen(popmat)$values[1])

# define a dynamics object
dyn <- dynamics(popmat)

# simulate from this (50 time steps, 100 replicates)
sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))

# plot the simulated trajectories
plot(sims)

# add some density dependence
dd <- density_dependence(
  masks = reproduction(popmat, dims = 4:5),
  funs = ricker(1000)
)

# update the dynamics object
dyn <- update(dyn, dd)

# simulate again
sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))

# and plot
plot(sims)

# what if we want to add initial conditions?
sims <- simulate(
  dyn,
  init = c(50, 20, 10, 10, 5),
  nsim = 100,
  options = list(ntime = 50),
)

# and plot again
plot(sims)

# note that there is only one trajectory now because
#   this simulation is deterministic.
#
# let's change that by adding some environmental stochasticity
envstoch <- environmental_stochasticity(
  masks = list(
    reproduction(popmat, dims = 4:5),
    transition(popmat)
  ),
  funs = list(
    function(x) rpois(n = length(x), lambda = x),
    function(x) rmultiunit(n = 1, mean = x, sd = 0.1 * x)
  )
)

# update the dynamics object and simulate from it
dyn <- update(dyn, envstoch)
sims <- simulate(
  dyn,
  init = c(50, 20, 10, 10, 5),
  nsim = 100,
  options = list(ntime = 50),
)

# the rmultiunit draws can be slow but we can speed
#   this up by calculating them once per generation
#   instead of once per replicate within each generation
envstoch <- environmental_stochasticity(
  masks = list(
    reproduction(popmat, dims = 4:5),
    transition(popmat)
  ),
  funs = list(
    function(x, ...) rpois(n = length(x), lambda = x),
    function(x, mean, sd) {
      pnorm(mean + sd * rnorm(length(x)))
    }
  )
)

# this requires an argument "function" that takes the
#   current state of the population model in each
#   iteration and calculates the correct arguments to
#   pass to environmental_stochasticty
envstoch_function <- function(obj, pop, iter) {
  mat <- obj$matrix
  if (is.list(mat))
    mat <- mat[[iter]]
  out <- unit_to_real(
    mat[transition(mat)], 0.1 * mat[transition(mat)]
  )
  list(mean = out[, 1], sd = out[, 2])
}

# update the dynamics object and simulate from it
dyn <- update(dyn, envstoch)
sims <- simulate(
  dyn,
  init = c(50, 20, 10, 10, 5),
  nsim = 100,
  args.fn = list(environmental_stochasticity = envstoch_function),
  options = list(ntime = 50),
)

# can also add covariates that influence vital rates
#   e.g., a logistic function
covars <- covariates(
  masks = transition(popmat),
  funs = function(mat, x) mat * (1 / (1 + exp(- 10 * x)))
)

# simulate 50 random covariate values
xvals <- matrix(runif(50), ncol = 1)

# update the dynamics object and simulate from it
#   - note that ntime is now captured in the 50 values
#     of xvals, assuming we pass xvals as an argument
#     to the covariates functions
dyn <- update(dyn, covars)
sims <- simulate(
  dyn,
  init = c(50, 20, 10, 10, 5),
  nsim = 100,
  args = list(covariates = list(x = xvals)),
  args.fn = list(environmental_stochasticity = envstoch_function)
)

}
