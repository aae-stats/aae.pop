[{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement jdl.yen@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://aae-stats.github.io/aae.pop/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/beyond_defaults.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Moving beyond default settings in aae.pop","text":"aae.pop sets default options speed process defining simulating population dynamics. defaults acceptable cases unlikely suit applications. vignette covers primary settings useful alternatives.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/beyond_defaults.html","id":"changing-simulation-settings","dir":"Articles","previous_headings":"","what":"Changing simulation settings","title":"Moving beyond default settings in aae.pop","text":"simulate function several relatively intuitive settings: nsim: number replicate simulations run. default 1. Increasing value makes sense including form variation, demographic environmental stochasticity multiple initial conditions. Replicate simulations vectorised, including replicates (cases) substantially faster multiple simulations nsim = 1. seed: random seed used initialise random draws. Defaults NULL, case seed current workspace used. Set value reproducible results required. options: basic settings control simulate works. Several -complex settings described Updaters Initial conditions, . ntime: number time steps simulate. Defaults 50 ignored covariates included model covariates determine number time steps. keep_slices: simulate return every intermediate time step? Defaults TRUE, set FALSE final time step required. reduce memory use, helpful large models. tidy_abundances: happens abundance estimates iteration? Defaults identity, means abundances left unchanged, potentially decimal values. good alternative floor, round nearest integer, implying fractional individuals exist. Can replaced function takes vector returns vector size (e.g., ceiling, round). settings can changed directly call simulate. options named list, modified call simulate might look like: Alternatively, certain settings need updated simulations project, might easier change deeper level global options R. Specifically, ntime, keep_slices, tidy_abundances set options can updated :","code":"sims <- simulate(   popdyn,   nsim = 100,   seed = 123,   options = list(ntime = 30, keep_slices = FALSE, tidy_abundances = floor) ) # ntime options(aae.pop_ntime = 30)  # keep_slices options(aae.pop_keep_slices = FALSE)  # tidy_abundances options(aae.pop_tidy_abundances = floor)"},{"path":"https://aae-stats.github.io/aae.pop/articles/beyond_defaults.html","id":"initials","dir":"Articles","previous_headings":"","what":"Initial conditions","title":"Moving beyond default settings in aae.pop","text":"Setting initial conditions really important part population dynamics modelling. default initial conditions aae.pop random Poisson draws mean 10. simplistic, assumes model run many generations transient dynamics interest. default initial conditions can changed several ways. First, mean Poisson distribution can changed setting initialise_args options argument simulate: Alternatively, value can changed simulations R session options function: slightly deeper level, Poisson distribution inappropriate, can changed function options function. form wrapper function restricted must include two arguments: n, integer, args, list arguments passed simulate initialise_args element options argument. initialisation function less restricted first argument must integer specifying number values simulate. function include structure abundances, differences among age classes replicates. complex initial conditions can passed simulate init argument. Initial conditions can specified vector one element per population class matrix (array) one row per replicate one column per population class. specified vector nsim greater 1, initial conditions assumed replicates. approach allows initial conditions amount structure detail:  previous example might bit unwieldy many replicates, case single vector can passed simulate:  Alternatively, approach modified add stochasticity initial conditions retaining structure previous examples:","code":"sims <- simulate(   popdyn,   options = list(initialise_args = 20) ) options(aae.pop_lambda = 20) # define your own initialisation function my_initials_function <- function(n, other_arguments) {   simulate_n_values_somehow(n = n, other_arguments)  # e.g. rnbinom, rlnorm, ... }  # this neeeds wrapping up so aae.pop can use it initials_function_wrapper <- function(n, args) {   do.call(my_initials_function, c(list(n), args)) }  # set this at the global level (i.e. for an entire R session) options(aae.pop_initialisation = initials_function_wrapper) # need a matrix/array with one row per replicate and one column #    per class (5 age classes in this example) my_initials <- matrix(   c(     100, 50, 25, 15, 5,   # first replicate     200, 100, 50, 30, 10, # second replicate     50, 25, 12, 8, 2      # third replicate   ),   nrow = 3,    # will set 3 replicates in simulate   ncol = 5,    # and 5 age classes   byrow = TRUE # this just makes formatting easier )  # simulate with these values sims <- simulate(   popdyn,   nsim = 3,   seed = 123,   init = my_initials,   options = list(tidy_abundances = floor) )  # plot this plot(   sims,   col = alpha(\"#2171B5\", 0.9),   main = \"Three different initial conditions\" ) # need a vector with one value per class (5 age classes, here) my_initials <- c(100, 50, 25, 15, 5)  # simulate with these values sims <- simulate(   popdyn,   nsim = 100,   seed = 123,   init = my_initials,   options = list(tidy_abundances = floor) )  # plot this plot(   sims,   col = alpha(\"#2171B5\", 0.4),   main = \"Many replicates with the same initial condition\" ) # generate a matrix with one row per replicate and one column #   per class (5 classes, 100 replicates), setting a different  #   mean (lambda) in each column my_initials <- matrix(   rpois(5 * 100, lambda = c(100, 50, 25, 15, 5)),   nrow = 100,   ncol = 5,   byrow = TRUE )  # simulate with these values sims <- simulate(   popdyn,   nsim = 100,   seed = 123,   init = my_initials,   options = list(tidy_abundances = floor) )  # plot this plot(   sims,   col = alpha(\"#2171B5\", 0.4),   main = \"Many replicates with stochastic, structured initial conditions\" )"},{"path":"https://aae-stats.github.io/aae.pop/articles/beyond_defaults.html","id":"updaters","dir":"Articles","previous_headings":"","what":"Updaters","title":"Moving beyond default settings in aae.pop","text":"update step abundances get updated one time step next (e.g., one generation). process typically slowest part simulating population dynamics, least realistically complex models.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/beyond_defaults.html","id":"built-in-updaters","dir":"Articles","previous_headings":"Updaters","what":"Built-in updaters","title":"Moving beyond default settings in aae.pop","text":"default updater aae.pop R’s built-cross product. method extremely fast vectorised, handles replicates easily. two catches: vectorisation efficient variation vital rates among replicates (common situation). approach doesn’t handle fairly common forms demographic stochasticity, drawing abundances Binomial distribution. cross product approach still recommended cases, outperforms R-based alternatives, including C++ tools written specifically matrix operations. updater can changed global level options function: aae.pop package includes two alternatives, incorporate demographic stochasticity using Binomial draws (update_binomial_leslie, Leslie matrices) multinomial draws (update_multinomial, matrices). approaches fast default cross product method.","code":"# change updater options(aae.pop_update = update_my_way)"},{"path":"https://aae-stats.github.io/aae.pop/articles/beyond_defaults.html","id":"roll-your-own-updater","dir":"Articles","previous_headings":"Updaters","what":"Roll your own updater","title":"Moving beyond default settings in aae.pop","text":"Although trivial, relatively easy define updater using bespoke method. updater function simply needs two input arguments, matrix replicate population vectors population matrix, needs return updated matrix replicate population vectors. population vectors always provided matrix replicates rows classes columns, population matrix always square matrix one row/column class. Looking inside built-updaters give insight structure aae.pop updaters. update_crossprod simply uses R’s tcrossprod function handle matrix replicate population vectors: update_binomial_leslie function slightly complicated includes check integer abundances uses mix Poisson (reproduction) Binomial draws (survival): primary reason change updater speed. Although update_crossprod relatively fast compared R methods, highly likely methods can sped , example, use C++ matrix libraries (e.g., RcppEigen RcppArmadillo). final updater use best determined benchmarking alternative updaters. Keep mind aae.pop built flexibility R compatibility rather speed per se. speed primary limitation concern, better approach might involve coding entire simulation process C++ similar.","code":"## function (pop, mat)  ## { ##     tcrossprod(pop, mat) ## } ## <bytecode: 0x559de44ade18> ## <environment: namespace:aae.pop> ## function (pop, mat)  ## { ##     if (!all((pop%%1) == 0)) { ##         stop(\"some abundances are not integers, so cannot be used \",  ##             \"with update_binomial_leslie. \", \"Check options()$aae.pop_tidy_abundances \",  ##             \"and update with an appropriate method (e.g. floor)\",  ##             call. = FALSE) ##     } ##     if (is.null(dim(pop))) { ##         pop <- matrix(pop, nrow = 1) ##     } ##     pop_nm1 <- pop[, -ncol(pop), drop = FALSE] ##     vals <- tcrossprod(pop, mat) ##     probs <- vals[, -1]/pop_nm1 ##     probs[pop_nm1 == 0] <- 0 ##     cbind(rpois(nrow(vals), lambda = vals[, 1]), matrix(rbinom(length(probs),  ##         size = pop_nm1, prob = probs), nrow = nrow(pop_nm1))) ## } ## <bytecode: 0x559de4f59948> ## <environment: namespace:aae.pop>"},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"installation-and-setup","dir":"Articles","previous_headings":"","what":"Installation and setup","title":"Get started with aae.pop","text":"can install aae.pop package CRAN: latest, development version aae.pop can installed GitHub remotes package: completed, able load aae.pop package library(aae.pop).","code":"install.packages(\"aae.pop\") install.packages(\"remotes\") remotes::install_github(\"aae-stats/aae.pop\")"},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"population-models","dir":"Articles","previous_headings":"Background","what":"Population models","title":"Get started with aae.pop","text":"aae.pop package requires elementary knowledge population models. comprehensive reference Hal Caswell’s Matrix Population Models (2nd edition, 2001, Sinauer Associates, Sunderland). Searching examples population viability analysis, population demographic models, matrix population models bring many alternative references.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"matrix-structures","dir":"Articles","previous_headings":"Background","what":"Matrix structures","title":"Get started with aae.pop","text":"aae.pop designed generic matrix models makes minimal assumptions model structure purpose. However, still assumptions built different functions documentation. important layout population matrix . aae.pop assumes columns move rows. example, value second row first column matrix specify transition stage 1 (column 1) stage 2 (row 2), , column 1 moves row 2. common layout population ecology standard disciplines. two population structures used frequently population ecology: Leslie matrix (age based) Lefkovitch matrix (life-stage based). Leslie matrix classifies age classes, transitions restricted reproduction survival next age class. Lefkovitch matrix classifies individuals life stages, transitions restricted reproduction, survival next life stage, survival remaining life stage. aae.pop includes several helper functions designed specifically two model types. described Including processes Beyond defaults vignettes.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"terminology","dir":"Articles","previous_headings":"Background","what":"Terminology","title":"Get started with aae.pop","text":"aae.pop uses three terms help specify common model structures: reproduction, survival, transition. defined follows: reproduction: transition first class (first row), often assumed exclude first column (.e., new individuals can’t reproduce). assumption enforced aae.pop, models can include reproduction first class. survival: surviving one time step remaining class. transition: surviving one time stpe moving next age class life stage. terms, Leslie matrix reproduction transition elements, whereas Lefkovitch matrix reproduction, transition, survival elements. course, matrix population models can values anywhere matrix, aae.pop supports models represented square matrix. flexibility important populations might require complex structures deal things like metapopulations, dormant stages, size-based models shrinkage well growth.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"building-a-basic-population-model","dir":"Articles","previous_headings":"","what":"Building a basic population model","title":"Get started with aae.pop","text":"central functions aae.pop dynamics simulate. dynamics function wraps population matrix specified processes single object. simulate function takes object generates population projections.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"the-population-matrix","dir":"Articles","previous_headings":"Building a basic population model","what":"The population matrix","title":"Get started with aae.pop","text":"good place start basic population matrix processes. example, Leslie matrix five age classes can specified : Using terminology , matrix specified : Although looks fairly unwieldy case, helper terms can useful large matrices.","code":"popmat <- rbind(   c(0,    0,    2,    4,    7),  # reproduction from 3-5 year olds   c(0.25, 0,    0,    0,    0),  # survival from age 1 to 2   c(0,    0.45, 0,    0,    0),  # survival from age 2 to 3   c(0,    0,    0.70, 0,    0),  # survival from age 3 to 4   c(0,    0,    0,    0.85, 0)   # survival from age 4 to 5 ) new_offspring <- c(2, 4, 7) transition_probabilities <- c(0.25, 0.45, 0.70, 0.85) popmat <- matrix(0, nrow = 5, ncol = 5) popmat[reproduction(popmat, dims = 3:5)] <- new_offspring popmat[transition(popmat)] <- transition_probabilities"},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"creating-a-population-dynamics-object","dir":"Articles","previous_headings":"Building a basic population model","what":"Creating a population dynamics object","title":"Get started with aae.pop","text":"population matrix defined, can compiled dynamics object following code: possible plot population dynamics object visualise transitions structure implies. requires DiagrammeR package. Visualising population structures can useful way check model specified correctly, plots easier communicate giant matrix. Plots dynamics objects can use custom labels labels argument (character vector one value class). Additionally, default assumption first stage reproductive can overwritten passing cycle_first = \"reproductive\" argument plot.","code":"popdyn <- dynamics(popmat) plot(popdyn)"},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"simulating-population-trajectories","dir":"Articles","previous_headings":"Building a basic population model","what":"Simulating population trajectories","title":"Get started with aae.pop","text":"compiled dynamics object, ’s relatively straightforward simulate population trajectories (default settings): Simulated trajectories can plotted using standard plot function R. example sets colour medium shade blue:","code":"sims <- simulate(popdyn) plot(sims, col = \"#2171B5\")"},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"changing-default-settings","dir":"Articles","previous_headings":"Building a basic population model","what":"Changing default settings","title":"Get started with aae.pop","text":"default settings simulate single trajectory 50 time steps, random initial conditions (Poisson draws λ=10\\lambda = 10). settings can changed directly call simulate: Default settings also specify population updates calculated cross product abundances rounded way step, allows fractional individuals population. ideal settings. Changing covered Beyond defaults vignette.","code":"initials <- c(100, 50, 20, 10, 5)  # some initial conditions sims <- simulate(   popdyn,   nsim = 100,   init = initials,   options = list(ntime = 20) )"},{"path":"https://aae-stats.github.io/aae.pop/articles/get_started.html","id":"summarise-simulated-trajectories","dir":"Articles","previous_headings":"Building a basic population model","what":"Summarise simulated trajectories","title":"Get started with aae.pop","text":"Simulated trajectories arrays dimensions replicates (rows) classes (columns) time steps (slices). arrays relatively easy summarise using apply functions aae.pop package includes several basic summary functions convenience. simple summary probability population hit zero individuals time step, plus expected minimum population size (EMPS), generated summary function. summary makes sense considering replicate population trajectories extinction probabilities defined proportion trajectories hitting zero individuals: vector printed bottom summary basic risk curve calculated ten different extinction thresholds (described ). components summary directly accessible: default settings pr_extinct, emps, risk_curve consider population classes, time steps, define extinction zero individuals population. Many applications require -nuanced definitions. three functions can calculated subset population (e.g., adults) reduced time period (e.g., generations 40-50). Extinction can defined levels zero individuals. example, population might considered functionally extinct destined become extinct 100 adults remain. quasi-extinction threshold controlled threshold parameter pr_extinct: Risk curves extension previous idea consider probabilities population declines multiple thresholds simultaneously. summary function calculates basic risk curve ten thresholds spaced evenly zero maximum observed abundance. commonly, risk curves focus multiple levels might represent categories extreme, high, moderate, mild, risk. values based many criteria often consider genetic factors risk inbreeding. emps function extracts minimum population size within replicate trajectory averages values trajectories. averaging defaults arithmetic mean can changed function using fun argument (see ?emps details). generalisation calculation provided exps function, x represents unknown function place minimum. exceptions, emps exps require summary functions return single values (scalars). Even restriction, exps allows flexible calculations calculate many different summary statistics. example, might informative calculate 95th percentile trajectory take median trajectories: summary functions provided convenient handling details subsetting population time steps. complicated functions implemented directly apply function output simulation object. example median population size time step:","code":"sims <- simulate(popdyn, nsim = 1000) summary(sims) ## Simulated population has a 0 probability of extinction and expected minimum population size of 50 individuals. ##  ## The probability of population declines below non-zero thresholds is: ##   n = 0  n = 28  n = 56  n = 84 n = 112 n = 140 n = 168 n = 196 n = 224 n = 252  ##   0.000   0.001   0.797   1.000   1.000   1.000   1.000   1.000   1.000   1.000 pr_extinct(sims) ## [1] 0 emps(sims) ## [1] 50.08462 risk_curve(sims, n = 10) ##     0    28    56    84   112   140   168   196   224   252  ## 0.000 0.001 0.797 1.000 1.000 1.000 1.000 1.000 1.000 1.000 pr_extinct(sims, subset = 3:5, times = 40:50) ## [1] 0 emps(sims, subset = 3:5, times = 40:50) ## [1] 20.28206 risk_curve(sims, subset = 3:5, times = 40:50, n = 10) ##     0     4     8    11    15    19    23    26    30    34  ## 0.000 0.000 0.000 0.001 0.037 0.322 0.778 0.973 0.999 1.000 pr_extinct(sims, threshold = 100, subset = 3:5, times = 40:50) ## [1] 1 risk_curve(sims, threshold = c(0, 10, 50, 100, 1000)) ##     0    10    50   100  1000  ## 0.000 0.000 0.475 1.000 1.000 exps(sims, fun_within = quantile, fun_among = median, probs = 0.95) ## [1] 127.7357 # subset the population to adults  sims <- subset(sims, subset = 3:5)  # drop the first 10 generations (the drop = FALSE #   argument is a safeguard that keeps the third array #   dimension when filtering to a single time step) sims <- sims[, , 11:51, drop = FALSE]  # sum abundances over all classes, which #   gives a matrix (2D array) with replicates #   in rows and time steps in columns abundance <- apply(sims, c(1, 3), sum)  # and calculate median over all trajectories, which #   requires keeping the second dimension (time steps) #   while iterating over the first apply(abundance, 2, median) ##  [1] 19.27207 17.24090 18.35532 20.53396 19.84797 18.58626 18.49707 19.50011 ##  [9] 20.05573 19.31365 18.95322 19.31671 19.80168 19.74123 19.36984 19.42135 ## [17] 19.71299 19.84010 19.70977 19.61029 19.75668 19.92148 19.92292 19.86478 ## [25] 19.89903 20.01619 20.08203 20.07402 20.08156 20.14749 20.22133 20.25135 ## [33] 20.26481 20.30572 20.36663 20.41371 20.44123 20.47413 20.52307 20.57264 ## [41] 20.61077"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"demographic-processes","dir":"Articles","previous_headings":"","what":"Demographic processes?","title":"Including demographic processes in a population model","text":"broad term mean many things. aae.pop focuses five main processes: demographic stochasticity: random variation outcomes individual processes (e.g. birth, death), resulting variation population abundances. environmental stochasticity: random variation external conditions, resulting variation vital rates (.e., population matrix). density dependence: variation vital rates population outcomes depends abundance population. Density dependence can negative (e.g., due limited resources) positive (e.g., Allee effects). covariate effects: influence covariates population matrix. aae.pop, covariate effects included primarily allow population matrix change time response external factors (e.g., weather, habitat availability, management interventions). additions removals: processes lead individuals added removed population. Additions removals defined broadly can capture things like population augmentation (e.g., stocking releases captive-bred individuals) targeted removals (e.g., angling predation). Two additional processes, dispersal interspecific interactions, covered Metapopulations Multiple species vignettes.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"an-aside-masks","dir":"Articles","previous_headings":"","what":"An aside: masks","title":"Including demographic processes in a population model","text":"processes unlikely consistent effects across vital rates classes population. deal , aae.pop built around concept masks. Masks used select specific elements population matrix, elements altered given process. Masks paired functions defining processes. Masks tell R cells target, functions tell R cells. Several helper functions included define common masks. include reproduction, survival, transition regions matrix discussed getting started vignette, well masks select entire population matrix (all_cells) abundance vector (all_classes). masks defined aae.pop return TRUE/FALSE matrix vector selects required cells. Masks defined way aae.pop flattens population matrix internal calculations, breaks cell-based subsetting (.e., [, j] R notation work). possible (advised) work around . discussion introduces one way work around masks highlights might good idea.","code":""},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"a-basic-model","dir":"Articles","previous_headings":"Back to demographic processes","what":"A basic model","title":"Including demographic processes in a population model","text":"Let’s start basic model used Getting started vignette. Leslie matrix five age classes, individuals reproducing ages 3-5. sufficient start simulating population dynamics, using dynamics simulate functions. However, adding additional processes requires steps first.","code":"popmat <- rbind(   c(0,    0,    2,    4,    7),  # reproduction from 3-5 year olds   c(0.25, 0,    0,    0,    0),  # survival from age 1 to 2   c(0,    0.45, 0,    0,    0),  # survival from age 2 to 3   c(0,    0,    0.70, 0,    0),  # survival from age 3 to 4   c(0,    0,    0,    0.85, 0)   # survival from age 4 to 5 )"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"demographic-stochasticity","dir":"Articles","previous_headings":"Back to demographic processes","what":"Demographic stochasticity","title":"Including demographic processes in a population model","text":"Random variation individual outcomes key feature population models. variation important (influential) populations small, small events (e.g., several individuals failing reproduce) can big effect population outcomes. Demographic stochasticity defined single mask corresponding function. simplest form demographic stochasticity case Poisson variation around expected number individuals next generation. can coded : , mask selects classes population vector function takes vector x returns random Poisson variates mean equal x. Note function potentially allows number surviving individuals class exceed number available individuals Poisson distribution upper bound. workaround , using Binomial distribution, covered Beyond defaults vignette. mask/function pair can combined single object demographic_stochasticity function. resulting demostoch object can passed directly dynamics, along population matrix. turn, creates dynamics object can used simulate.  simple example includes one mask/function pair, demographic_stochasticity function can chain together many different mask/function pairs required. cases, one mask function, set masks/functions passed demographic_stochasiticity list (e.g., masks = list(demostoch_mask1, demostoch_mask2)).","code":"demostoch_mask <- all_classes(popmat) # affects all classes demostoch_fn <- function(x) {   rpois(length(x), lambda = x) } demostoch <- demographic_stochasticity(   masks = demostoch_mask,   funs = demostoch_fn ) # create population dynamics object popdyn <- dynamics(popmat, demostoch)  # simulate population dynamics sims <- simulate(popdyn, nsim = 100)  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"environmental-stochasticity","dir":"Articles","previous_headings":"Back to demographic processes","what":"Environmental Stochasticity","title":"Including demographic processes in a population model","text":"Environmental stochasticity defined two masks corresponding functions. simplest form variation reproduction Poisson variation around expected number new individuals. can coded : , mask selects reproductive output age classes 3 5 population matrix function takes vector x returns random Poisson variates mean equal x. second mask/function pair add variation survival outcomes. case, simple form variation add subtract small value survival probabilities. can coded : , mask selects elements sub-diagonal population matrix, function takes vector x returns new value deviation -0.1 0.1. one extra check function make sure new probabilities still probabilities (.e., still 0 1). two mask/function pairs can combined single object environmental_stochasticity function. resulting envstoch object can passed directly dynamics, along population matrix. turn, creates dynamics object can used simulate.  easy include environmental demographic stochasticity model. dynamics call simply needs envstoch demostoch objects. case update function comes handy. Rather re-defining population dynamics object, existing version popdyn (included popmat envstoch) can simply updated include demostoch:","code":"reproduction_mask <- reproduction(popmat, dims = 3:5) # only ages 3-5 reproduce reproduction_fn <- function(x) {   rpois(length(x), lambda = x) } transition_mask <- transition(popmat) # all classes this time transition_fn <- function(x) {      # add a random deviation to x   deviation <- runif(length(x), min = -0.1, max = 0.1)   x <- x + deviation      # make sure the result isn't negative or greater than 1   x[x < 0] <- 0   x[x > 1] <- 1      # return the value   x    } envstoch <- environmental_stochasticity(   masks = list(reproduction_mask, transition_mask),   funs = list(reproduction_fn, transition_fn) ) # create population dynamics object popdyn <- dynamics(popmat, envstoch)  # simulate population dynamics sims <- simulate(popdyn, nsim = 100)  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4)) # update population dynamics object popdyn <- update(popdyn, demostoch)  # simulate population dynamics sims <- simulate(popdyn, nsim = 100)  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"density-dependence","dir":"Articles","previous_headings":"Back to demographic processes","what":"Density dependence","title":"Including demographic processes in a population model","text":"Density dependence occurs vital rates individual outcomes depend population abundance. common form density dependence population ecology negative density dependence, , reduction vital rates increases population abundance. Negative density dependence typically observed changes reproduction due , example, increased competition resources resulting high mortality new individuals. Density dependence can included exactly way environmental stochasticity: mask tells R cells population matrix affected abundances function tells R cells. case, function passed vital rates well vector abundances population class. aae.pop pre-defined functions two common forms density dependence: Ricker model Beverton-Holt model. Ricker model assumes mortality rates new individuals proportional adult population size due scramble competition (equal division resources). Beverton-Holt model assumes mortality rates new individuals linearly dependent number individuals due contest competition (unequal division resources). Importantly, Ricker model overcompensatory, means can increase mortality rates point complete mortality. occur Beverton-Holt model. aae.pop, models specified two parameters: k, represents carrying capacity population; theta, represents strength density dependence. theta re-scales population sizes, mathematically equivalent adjusting k (e.g., theta = 0.5; k = k theta = 1; k = 2 * k give outcome). functions include one extra argument, exclude, allows estimates carrying capacity defined subset population classes (e.g., adult abundances ). Ricker model can specified follows:  Density dependence can take many forms. forms may include positive density dependence (e.g., Allee effects) may affect adult abundances well reproduction. next section introduces example latter.","code":"# specify a Ricker model for density dependence dd <- density_dependence(   masks = reproduction(popmat, dims = 3:5), # only adults reproduce   funs = ricker(k = 40, exclude = 1:2)      # set k based on adult abundances )  # update the population dynamics object to include density dependence popdyn <- update(popdyn, dd)  # simulate population dynamics sims <- simulate(popdyn, nsim = 100)  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"a-different-form-of-density-dependence","dir":"Articles","previous_headings":"Back to demographic processes","what":"A different form of density dependence","title":"Including demographic processes in a population model","text":"Density dependence commonly assumed affect new individuals entering population. However, possible density dependence also affects adults, example, high abundances limit access suitable habitat. Effects adult survival modelled using approach outlined previous section, transition survival masks alongside reproduction mask. alternative approach model density dependence direct effects population abundances. Although linked directly vital rates (e.g., survival), approach can easier implement can capture processes directly affect vital rates, fishing, hunting, logging. add_remove_pre add_remove_post functions can used define form density dependence (_pre: reproduction; _post: reproduction). functions described detail replace now-deprecated density_dependence_n function. case, mask needs select relevant classes population, function takes one argument, vector population abundances. approach can implemented follows:","code":"# specify density dependence that removes 10 % of adults in each generation dd_n <- add_remove_post(   masks = all_classes(popmat, dims = 3:5), # want to focus on adults   funs = function(n) 0.9 * n               # define in-line function to return   #   90 % of adult population )  # create a new population dynamics object popdyn <- dynamics(popmat, envstoch, demostoch, dd_n)  # simulate population dynamics sims <- simulate(popdyn, nsim = 100)  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"covariates","dir":"Articles","previous_headings":"Back to demographic processes","what":"Covariates","title":"Including demographic processes in a population model","text":"Population dynamics often depend external factors (covariates, ). aae.pop uses mask/function approach described include effects covariates vital rates. function takes vital rates first argument, followed arguments required specify covariate values effects. example illustrates clearly:  Specifying covariates term automatically include covariates model. Note nesting variable also passed simulate via args argument. reason allows single population dynamics object (popdyn, ) used multiple different sets covariates, without re-compiling dynamics object time. format_covariates function included format covariate values list one element per time step. formatted covariates can combined static covariates collating everything super-list: aae.pop assumes least one argument covariates changes time, consequence specifying covariates vector/matrix covariates determines number simulated time steps (n_time). example, 20 values nesting, translates 21 time steps (initial condition plus 20 updates). assumed covariates passed list one element time step. complex covariate terms possible, combination static dynamic arguments functions specify arguments based current state population. terms can passed simulate via args argument (see help files format_covariates examples).","code":"# set up 20 years of covariates, such as proportion of available nesting sites nesting <- runif(20, min = 0.5, max = 1.0)    # 50 % to 100 % of total sites available in each year  # define the mask covar_mask <- reproduction(popmat, dims = 3:5)  # assume nesting sites only affect reproduction  # define a function that links vital rates to the covariates #   (dots to soak up any extra arguments passed to other functions) covar_fn <- function(x, nests, ...) {   x * nests    # really simple function, assume the proportion of successful reproduction   #   attempts is equal to the proportion of nests }  # combine this into a covariates term covs <- covariates(covar_mask, covar_fn)  # create population dynamics object (without density dependence) popdyn <- dynamics(popmat, envstoch, demostoch, covs)  # simulate population dynamics sims <- simulate(   popdyn,   nsim = 100,   args = list(covariates = format_covariates(nesting)) )  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4)) sims <- simulate(   popdyn,   nsim = 100,   args = list(     covariates = c(       format_covariates(nesting),       list(static_argument1 = 0.05),       list(static_argument2 = 100)     )   ) )"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"fine-grained-control-of-covariate-effects","dir":"Articles","previous_headings":"Back to demographic processes","what":"Fine-grained control of covariate effects","title":"Including demographic processes in a population model","text":"Simulated populations can include default covariates terms applied consistently replicate trajectories. cases, may useful specify covariate effects specific trajectory. replicated_covariates process included address situation, allows covariate functions act full vector vital rates replicate-specific arguments effects. simplest way set (visualise) replicated_covariates term define matrix nsim columns ntime rows. column matrix specifies covariate values/arguments applied single replicate trajectory, row specifies effects (replicates) single time step. One application replicated_covariates (reason approach developed) allow variation uncertainty vital rates single simulation. structure, input matrix can defined variation (e.g., representing environmental variability) around different mean values (representing uncertainty), without run multiple simulations.","code":"# set up 20 years of covariates, such as proportion of available nesting sites, #   but now with a different minimum (and, therefore, mean) value for each replicate nesting <- do.call(cbind, lapply(runif(100, min = 0.5, max = 0.8), \\(x) runif(20, min = x, max = 1.0)))  # define the mask covar_mask <- reproduction(popmat, dims = 3:5)  # assume nesting sites only affect reproduction  # define a function that links vital rates to the covariates #   (dots to soak up any extra arguments passed to other functions) covar_fn <- function(x, nests, ...) {   x * nests    # really simple function, assume the proportion of successful reproduction   #   attempts is equal to the proportion of nests }  # combine this into a covariates term covs <- replicated_covariates(covar_mask, covar_fn)  # create population dynamics object (without density dependence) popdyn <- dynamics(popmat, envstoch, demostoch, covs)  # simulate population dynamics sims <- simulate(   popdyn,   nsim = 100,   args = list(replicated_covariates = format_covariates(nesting)) )  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"adding-or-removing-individuals-from-a-population","dir":"Articles","previous_headings":"Back to demographic processes","what":"Adding or removing individuals from a population","title":"Including demographic processes in a population model","text":"Many processes might lead individuals added removed population. add_remove_pre add_remove_post functions defined generically capture process, pre version applied prior reproduction post version applied following reproduction. Similar demographic stochasticity, additions removals act population state vector (counts class) rather population matrix (vital rates). Importantly, add_remove_pre way state vector can modified reproduction. Examples additions include fish stocking releases captive-bred individuals. Examples removals include angling predation individuals, noting also applied covariates acting survival rates. simple example can illustrate general approach.","code":"# set up a release of 10 individuals each year into the first age class, #   occurring after reproduction captives <- add_remove_post(   masks = all_classes(popmat, dims = 1),   funs = \\(x) x + 10 )  # repeat to remove 2 adults via predation each year, prior to reproduction predators <- add_remove_pre(   masks = all_classes(popmat, dims = ncol(popmat)),   funs = \\(x) ifelse(x >= 2, x - 2, 0) )  # create population dynamics object (without density dependence) popdyn <- dynamics(popmat, envstoch, demostoch, captives, predators)  # simulate population dynamics sims <- simulate(   popdyn,   nsim = 100 )  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/including_processes.html","id":"nomask","dir":"Articles","previous_headings":"","what":"What if I don’t want to use masks?","title":"Including demographic processes in a population model","text":"mask/function approach central aae.pop. approach allows multiple functions combined single term makes easier keep track (update) individual functions masks. secondary reason approach computational. Rarely demographic processes act entire population matrix. dealing large matrices (e.g., 50-100 classes), ’s much efficient pass small parts matrix entire matrix. might situations entire population matrix need modified given process. still supported aae.pop all_cells mask. However, isn’t possible subset matrix within function using R’s standard [, j] notation. functions within aae.pop receive flattened (masked) version population matrix, actually looks like: ’s essential use [, j] subsetting inside function, workaround reconstruct matrix within function passing dimensions args argument simulate. might look bit like:","code":"# reproduction mask popmat[reproduction(popmat, dims = 3:5)] ## [1] 2 4 7 # transition mask popmat[transition(popmat)] ## [1] 0.25 0.45 0.70 0.85 # all elements popmat[all_cells(popmat)] ##  [1] 0.00 0.25 0.00 0.00 0.00 0.00 0.00 0.45 0.00 0.00 2.00 0.00 0.00 0.70 0.00 ## [16] 4.00 0.00 0.00 0.00 0.85 7.00 0.00 0.00 0.00 0.00 # define a function no_mask_fn <- function(x, dim) {      # reconstruct matrix   x <- array(x, dim = dim)      # change elements with [i, j] notation   x[2, 1] <- 0.6 * x[2, 1]   x[3, 2] <- 1.25 * x[3, 2]      # return   x    }  # set this up as a form of environmental stochasticity envstoch <- environmental_stochasticity(   masks = all_cells(popmat),  # pass the entire matrix   funs = no_mask_fn           # use the no-mask function )  # create population dynamics object (without density dependence) popdyn <- dynamics(popmat, envstoch)  # simulate population dynamics sims <- simulate(   popdyn,   nsim = 100,   args = list(environmental_stochasticity = list(dim = dim(popmat))) )  # plot the population trajectories plot(sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Population dynamics of Macquarie perch","text":"example uses model Macquarie perch (Macquaria australasica) population dynamics illustrate several advanced features aae.pop. Specifically, example demonstrates complex forms density dependence use multiple types args simulate, supports dynamic arguments depend state population time step. Macquarie perch model presented early implementation since updated new information. updated template included aae.pop.templates package, can installed Github remotes::install_github(\"aae-stats/aae.pop.templates\"). Macquarie perch freshwater fish species native Murray-Darling Basin south-eastern Australia. Macquarie perch large (46 cm 3.5 kg), long-lived (30 years) species, historically abundant throughout southern Murray-Darling Basin, supporting important recreational fishery 1980s. Macquarie perch since undergone dramatic decline range abundance, point now considered locally extinct across much former range, listed nationally endangered species. model outlined includes age-specific survival reproduction 30 age classes well eggs larvae. Survival reproduction density dependent spawning success varies among years. model includes effects variable flow conditions allows individuals (adults juveniles) added removed population given year simulate effects stocking recreational fishing.","code":""},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"the-population-matrix","dir":"Articles","previous_headings":"Building a population model for Macquarie perch","what":"The population matrix","title":"Population dynamics of Macquarie perch","text":"population matrix important part population dynamics model. population matrix Macquarie perch substantially complex vignettes examples. Notably, matrix includes 30 age classes, vital rates defined functions age. Individuals become reproductively mature 3-4 years, fecundity increases age (Todd Lintermans 2015). age-fecundity relationship can characterised three-parameter function (derived Todd Lintermans (2015)). relationship captured following R function:  Survival peaked relationship age, increasing individuals approximately 20 years age declining point onwards (Todd Lintermans 2015). relationship captured following parameters:  values sufficient construct (mean) population matrix: population matrix much complex examples Getting started vignette, yet form supports deterministic projections Macquarie perch populations constant vital rates processes operating (e.g., density dependence). following sections add several additional processes create -complete model Macquarie perch population dynamics.","code":"# function to simulate reproductive output of Macquarie perch fecundity <- function(     age,                             # vector of ages     mean = c(1.68, -0.302, 2.886),   # mean parameters for fecundity function     early_surv = c(0.5, 0.013, 0.13) # estimates of early life survival (eggs, larvae, young-of-year) ) {    # mean estimates of three model parameters   y1 <- mean[1]   y2 <- mean[2]   y3 <- mean[3]    # calculate fecundity   y2_term <- exp(y2 * age)   y1_y2 <- log(43.15 * exp(- y1 * y2_term))   fec <- exp(2.295 * y1_y2 + y3)    # add early life survival and muliply by 0.5   #   to account for a 50:50 sex ratio   0.5 * fec * prod(early_surv)  }  # plot mean fecundity as a function of age age_vec <- seq(3, 30, length = 100) plot(fecundity(age_vec) ~ age_vec, las = 1, type = \"l\", xlab = \"Age\", ylab = \"Fecundity\", bty = \"l\", lwd = 2, col = alpha(\"#2171B5\", 0.9)) # define survival parameters survival_params <- c(   0.25, 0.44, 0.56, 0.63, 0.69, 0.72, 0.75, 0.78, 0.79,   0.81, 0.82, 0.83, 0.83, 0.84, 0.84, 0.84, 0.85, 0.85, 0.84,   0.84, 0.84, 0.83, 0.82, 0.80, 0.78, 0.76, 0.71, 0.63, 0.48 )  # plot mean survival as a function of age plot(survival_params ~ c(1:29), las = 1, type = \"l\", xlab = \"Age\", ylab = \"Survival\", bty = \"l\", lwd = 2, col = alpha(\"#2171B5\", 0.9)) # define population matrix nclass <- length(survival_params) + 1 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[transition(popmat, dims = 1:30)] <- survival_params popmat[reproduction(popmat, dims = 3:30)] <- fecundity(3:30)  # convert this to a dynamics object and plot it popdyn <- dynamics(popmat) plot(popdyn)"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"density-dependence","dir":"Articles","previous_headings":"Building a population model for Macquarie perch","what":"Density dependence","title":"Population dynamics of Macquarie perch","text":"Density dependence introduced Including processes vignette. Macquarie perch present interesting case study, density dependence operates reproduction, Allee effect positive density dependence, survival, negative, top-effect competitive interactions habitat (Todd Lintermans 2015). effects can captured following R functions: functions include ... arguments used functions . necessary non-standard arguments passed simulate given demographic process. case, allee_strength allee_factor arguments can (optionally) set directly call simulate, pass arguments functions included density_dependence object. Without ... arguments, break topdown_fn use allee_strength allee_factor terms. ... argument absorbs extra terms. Although required allee_fn, adding ... way can useful safeguard models may updated future.","code":"# masks: survival and reproduction of 3-30 year olds density_masks <- list(   transition(popmat),   reproduction(popmat, dims = 3:30) )  # top-down effects of competition for habitat, #    arbitrary carrying capacity of 1000 here #    (could be passed as an arg) topdown_fn <- function(mat, pop, ...) {   sum_n <- sum(pop[3:30])   ifelse(sum_n > 1000, 1000 / sum_n, 1) * mat }  # positive density dependence (Allee effect) allee_fn <- function(mat, pop, allee_strength = 1, allee_factor = 10, ...) {   sum_n <- sum(pop[3:30])   allee <- (2 / (1 + exp(-sum_n / (allee_strength * allee_factor)))) - 1   mat <- allee * mat   mat }  # combine the functions into a list density_fns <- list(   topdown_fn,   allee_fn )  # and collate masks and functions in a single object dens_depend <- density_dependence(   masks = density_masks,   funs = density_fns )"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"environmental-stochasticity","dir":"Articles","previous_headings":"Building a population model for Macquarie perch","what":"Environmental stochasticity","title":"Population dynamics of Macquarie perch","text":"population matrix density dependence defined entirely deterministic. section add environmental stochasticity population matrix, demonstrating relatively slow rmultiunit function trick args.fn option speed simulate situation.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"aside-why-use-a-slow-function","dir":"Articles","previous_headings":"Building a population model for Macquarie perch > Environmental stochasticity","what":"Aside: why use a slow function?","title":"Population dynamics of Macquarie perch","text":"runit rmultiunit functions included aae.pop handle situations stochastic values required unit [0, 1] interval. many ways simulate values interval commonly used methods return values known mean, standard deviation, correlation structure (multivariate case). solution involves solving several relatively messy equations identify transformed means standard deviations real line (.e., negative positive infinity), generating random Normal variates, converting back unit interval cumulative distribution transform. rmultiunit function fast. focus future development aae.pop, likely requiring function written C++ similar, low-level language. runit function can used follows: rmultiunit similar runit generates multivariate outcomes, .e., vectors values. case, mean sd vectors replicates determine number vectors simulated. approach can also include correlation structure simulated values, although level detail unusual practice due lack information empirical correlations: easy verify runit rmultiunit return values approximately correct means, standard deviations, correlations. final example , means : standard deviations : Last, correlations : Although values match perfectly, close match increasingly well samples.","code":"# generate 10 random values on the unit line (between 0 and 1) with known mean and sd runit(10, mean = 0.25, sd = 0.2) ##  [1] 0.01335603 0.15140413 0.15195683 0.14524122 0.10364240 0.35541182 ##  [7] 0.76123961 0.01913061 0.32329943 0.01232927 # repeat this, but increase the standard deviation, noting the values still sit in [0, 1] runit(10, mean = 0.25, sd = 0.5) ##  [1] 0 0 0 0 0 0 0 1 1 0 # generate 10 random vectors of 5 values each, on the unit line rmultiunit(10, mean = c(0.5, 0.2, 0.1, 0.9, 0.6), sd = c(0.1, 0.05, 0.05, 0.05, 0.2)) ##            [,1]      [,2]       [,3]      [,4]      [,5] ##  [1,] 0.4042997 0.1954197 0.05807149 0.8155790 0.8033768 ##  [2,] 0.5182182 0.2086143 0.19305626 0.9139798 0.5851410 ##  [3,] 0.3105105 0.1825705 0.07728366 0.9495308 0.6319124 ##  [4,] 0.4343029 0.1937294 0.07989649 0.9280398 0.9738577 ##  [5,] 0.5048048 0.2263395 0.09688891 0.7834325 0.7910241 ##  [6,] 0.4748996 0.1860864 0.09209697 0.9101962 0.7335159 ##  [7,] 0.2780553 0.3552867 0.07531379 0.9184629 0.8255572 ##  [8,] 0.4316597 0.2564985 0.08013532 0.8401103 0.3867735 ##  [9,] 0.6086022 0.2028585 0.11643803 0.8009074 0.2798417 ## [10,] 0.5293154 0.2696519 0.10286138 0.9565959 0.7284069 # repeat this, but with a known correlation structure omega_est <- rbind(   c(1,    0,    0.15, 0,    0),   c(0,    1,    0,    0.75, 0),   c(0.15, 0,    1,    0,    0.25),   c(0,    0.75, 0,    1,    0),   c(0,    0,    0.25, 0,    1) ) unit_sims <- rmultiunit(   10000,   mean = c(0.5, 0.2, 0.1, 0.9, 0.6),   sd = c(0.1, 0.05, 0.05, 0.05, 0.2),   Omega = omega_est ) ## [1] 0.5 0.2 0.1 0.9 0.6 ## [1] 0.10 0.05 0.05 0.05 0.20 ##       [,1] [,2]  [,3]  [,4]  [,5] ## [1,]  1.00 0.00  0.16 -0.01  0.02 ## [2,]  0.00 1.00  0.00  0.75  0.00 ## [3,]  0.16 0.00  1.00 -0.01  0.25 ## [4,] -0.01 0.75 -0.01  1.00 -0.01 ## [5,]  0.02 0.00  0.25 -0.01  1.00"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"back-to-environmental-stochasticity","dir":"Articles","previous_headings":"Building a population model for Macquarie perch > Environmental stochasticity","what":"Back to environmental stochasticity","title":"Population dynamics of Macquarie perch","text":"Forging ahead rmultiunit approach, section use related function (rmultiunit_from_real) includes part rmultiunit calculation. function takes pre-transformed estimates mean standard deviation, removes slowest step rmultiunit calculation. possible mean vital rates change per time step (covariates included), changes rates (e.g., density dependence) occur incorporating environmental stochasticity. Therefore, conversion means standard deviations real line can occur per time step rather every single replicate within time step. first step define functions use within environmental_stochasticity process. functions assume means standard deviations already converted real-line equivalents; conversion use simulate covered . introduced Including processes vignette, environmental_stochasticity process adds variation vital rates combination masks functions: conversion means standard deviations unit interval real-line equivalents supported unit_to_real function. function can wrapped passed simulate args.fn option. option allows functions define arguments demographic processes based three inputs: population dynamics object, state population given time step, iteration index (.e., current year generation). alternative approach use args.dyn option, takes list arguments, one element time step. example, args.fn requires function takes survival estimates (unit interval) converts real-line equivalents. conversion requires information standard deviations, well survival estimates early life stages (eggs, larvae, young--year):","code":"# define masks for environmental stochasticity envstoch_masks <- list(   transition(popmat),                 # all survival estimates   reproduction(popmat, dims = 3:30)   # reproduction from all adults )  # define a survival function, adding dots to soak up extra arguments within simulate survival_gen <- function(mat, mean_real, sd_real, ...) {   rmultiunit_from_real(n = 1, mean_real = mean_real, sd_real = sd_real) }  # define a reproduction function, being careful with argument names to avoid conflicts #   with any arguments in survival_gen, which would then require multiple different #   arguments with the same name in simulate reproduction_gen <- function(     mat,     fec_mean = c(1.68, -0.302, 2.886),     fec_sd = c(0.3, 0.05, 0.15),     early_mean,     early_sd,     ... ) {    # need a vector of ages, hard coded here (could be an argument)   age <- 3:30    # generate stochastic values for early life survival (eggs, larvae, young-of-year)   early_real <- rmultiunit_from_real(n = 1, mean = early_mean, sd = early_sd)    # otherwise draw random variates for the three model parameters   y1 <- rnorm(n = 1, mean = fec_mean[1], sd = fec_sd[1])   y2 <- rnorm(n = 1, mean = fec_mean[2], sd = fec_sd[2])   y3 <- rnorm(n = 1, mean = fec_mean[3], sd = fec_sd[3])    # generate reproduction estimates for all adult age classes, incorporating   #   stochastic early life estimates   y2_term <- exp(y2 %o% age)   y1_y2 <- log(     43.15 * exp(sweep(y2_term, 1, -y1, \"*\"))   )   reprod <- exp(sweep(2.295 * y1_y2, 1, y3, \"+\"))    # add early life survival and muliply by 0.5   #   to account for a 50:50 sex ratio   0.5 * reprod * prod(early_real)  }  # combine masks and functions into a single object envstoch <- environmental_stochasticity(   masks = envstoch_masks,   funs = list(survival_gen, reproduction_gen) ) transform_survival <- function(obj, pop, iter) {    # pull out the population matrix in the current time step   mat <- obj$matrix   if (is.list(mat))     mat <- mat[[iter]]    # wrap up all survival means and SDs, including early life   #  (this allows a single call to `unit_to_real`, which is slow)   survival_mean <- c(     0.5, 0.013, 0.13,     # early life     mat[transition(mat)]  # from population matrix in current time step   )   survival_sd <- c(     0.1, 0.007, 0.028,  # early life     0.05, 0.09, 0.11, 0.10, 0.10, 0.07, 0.08, 0.08, 0.08,     0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08,     0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.07, 0.06, 0.05   )    # convert unit interval to real line equivalents   out <- unit_to_real(     unit_mean = survival_mean,     unit_sd = survival_sd   )    # separate early life from other estimates   idx <- seq_len(nrow(out)) > 3    # return   list(mean_real = out[idx, 1],    # for survival_gen        sd_real = out[idx, 2],      # for survival_gen        early_mean = out[!idx, 1],  # for reproduction_gen        early_sd = out[!idx, 2]     # for reproduction_gen   )  }"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"adding-and-removing-individuals","dir":"Articles","previous_headings":"Building a population model for Macquarie perch","what":"Adding and removing individuals","title":"Population dynamics of Macquarie perch","text":"additional process model Macquarie perch population dynamics inclusion stocking fishing. processes included directly population matrix effects survival reproduction. section demonstrates alternative way accounting addition removal individuals, using add_remove_post construct, allows density-dependent changes population vector (.e., abundances) following updates. approach requires mask selects classes population affected, well function determines population abundances altered. dd_n function entirely deterministic static, , fixed number individuals added removed every time step. extension approach set number individuals stochastically (e.g., Poisson random variable) make number individuals change time. example, args argument simulate include time-varying value n, dd_n function use pop (actual abundances) define density-dependent addition removal scenario. extensions shown example function argument included macquarie_perch template aae.pop.templates package, used simulate changes fishing regulations stocking time.","code":"# take a population vector and update it to add or remove n individuals #   split into two stages (juveniles, adults) dd_n <- function(pop, n, add = TRUE) {    # are we removing individuals?   if (!add) {      # check that there are enough juveniles     if (n[1] > sum(pop[1:2])) {       n[1] <- sum(pop[1:2])       warning(\"removing more juveniles than available;\",               \" total removals reduced to \", sum(pop[1:2]),               call. = FALSE)     }      # check that there are enough adults     if (n[2] > sum(pop[3:30])) {       n[2] <- sum(pop[3:30])       warning(\"removing more adults than available;\",               \" total removals reduced to \", sum(pop[3:30]),               call. = FALSE)     }      # expand n to remove from random age classes     n_juvenile_by_age <- rep(1:2, times = pop[1:2])     juvenile_idx <- sample.int(       length(n_juvenile_by_age), size = n[1], replace = FALSE     )     n_juvenile <- table(n_juvenile_by_age[juvenile_idx])     n_adult_by_age <- rep(3:30, times = pop[3:30])     adult_idx <- sample.int(       length(n_adult_by_age), size = n[2], replace = FALSE     )     n_adult <- table(n_adult_by_age[adult_idx])    } else {      # sample random classes to add individuals     n_juvenile <- table(       sample(1:2, size = n[1], replace = TRUE)     )     n_adult <- table(       sample(3:30, size = n[2], replace = TRUE)     )    }    # convert from a vector of classes to a count for each class   n_juvenile_expanded <- rep(0, 2)   names(n_juvenile_expanded) <- as.character(1:2)   n_juvenile_expanded[names(n_juvenile)] <- n_juvenile   n_adult_expanded <- rep(0, 28)   names(n_adult_expanded) <- as.character(3:30)   n_adult_expanded[names(n_adult)] <- n_adult   n <- c(n_juvenile_expanded, n_adult_expanded)    # adding is the opposite of removing   if (add)     n <- -n    # update pop abundances and return   pop - n  }  # wrap this up in a add_remove_post object (formerly density_dependence_n) add_remove <- add_remove_post(   masks = all_classes(popmat),   funs = dd_n )"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"covariate-effects","dir":"Articles","previous_headings":"Building a population model for Macquarie perch","what":"Covariate effects","title":"Population dynamics of Macquarie perch","text":"final demographic process included Macquarie perch population model (deterministic) covariate effects vital rates. definition effects assumes vital rates shown maximum values, covariates reducing survival recruitment relative maximum values. Covariates included four patterns observed Macquarie perch Lake Dartmouth: Recruitment young individuals peaked relationship discharge November December. Recruitment reduced discharge 50 % 100 % long-term average period. Recruitment reduced discharge highly variable November December. Recruitment reduced lake level increased substantially relative previous year. Adult survival reduced discharge lake drops 100 % long-term average. Several effects relate river discharge rather lake conditions adults population move lake adjacent river channel spawn. covariate effects can captured following masks functions: three recruitment effects share mask, reason included single function. Separating effects useful allows effects added removed easily without editing underlying functions. four functions also share input covariate, x, subsetting occurring within functions using R’s $ subsetting approach. requires x passed data.frame column names matching used functions (spawning_discharge, spawning_variability, water_level_change, average_daily_discharge). definition inclusion covariates simulate shown following section.","code":"# effect 1: recruitment has peaked association with Nov/Dec discharge recruit_peaked <- function(mat, x, ...) {    # define a quadratic association with log-transformed discharge   log_discharge <- log(x$spawning_discharge + 0.01)   scale_factor <- exp(-0.1 * log_discharge - 0.1 * (log_discharge ^ 2))    # make sure values are in the [0, 1] range   scale_factor[scale_factor > 1] <- 1   scale_factor[scale_factor < 0] <- 0    # return re-scaled recruitment values   mat * scale_factor  }  # effect 2: recruitment reduced in variable Nov/Dec conditions recruit_variability <- function(mat, x, ...) {   mat * exp(-0.05 * x$spawning_variability) }  # effect 3: recruitment reduced with rising lake level recruit_level <- function(mat, x, ...) {   mat * (1 / (1 + exp(-0.5 * (x$water_level_change + 10)))) }  # effect 4: adult survival reduced by low-discharge conditions adult_low <- function(mat, x, ...) {    # define a quadratic association with log-transformed discharge   log_discharge <- log(x$average_daily_discharge + 0.01)   scale_factor <- exp(0.3 * log_discharge - 0.3 * (log_discharge ^ 2))    # make sure values are in the [0, 1] range   scale_factor[scale_factor > 1] <- 1   scale_factor[scale_factor < 0] <- 0    # return re-scaled survival values   mat * scale_factor  }  # define masks covar_masks <- list(   reproduction(popmat),   reproduction(popmat),   reproduction(popmat),   transition(popmat, dims = 3:30) )  # link functions to masks covar_funs <- list(   recruit_peaked,   recruit_variability,   recruit_level,   adult_low )  # collate into a single object covars <- covariates(   masks = covar_masks,   funs = covar_funs )"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"simulating-population-dynamics","dir":"Articles","previous_headings":"","what":"Simulating population dynamics","title":"Population dynamics of Macquarie perch","text":"demographic processes defined, straightforward define dynamics object. , can simply update dynamics object defined earlier: Simulating object requires call simulate, also recalling least one function argument required transform survival values unit interval real-line equivalents:  simulated abundances extremely high given expected population sizes system. primary reason model assumes ideal conditions year, covariate effects used reduce vital rates match actual conditions. Covariates can added model following code, noting popdyn object can used without covariates:  simulated trajectories now look much realistic. , large values reflect young individuals, many survive adulthood. Plotting older classes alone highlights effect:","code":"# update previously defined population dynamics object #   (which only included popmat) popdyn <- update(   popdyn,   covars,   envstoch,   dens_depend,   add_remove ) # simulate, using the transform_survival function defined above #   to update arguments passed to environmental_stochasticity and #   adding arguments to specify 100 juveniles and 10 adults #   removed per time step (e.g., due to fishing) sims <- simulate(   popdyn,   nsim = 100,   args = list(     add_remove_post = list(n = c(100, 20), add = FALSE),     environmental_stochasticity = list(transform_survival)   ) )  # plot the simulated trajectories, removing some really large values plot(sims, col = alpha(\"#2171B5\", 0.4)) # simulate 30 years of covariate values based on ranges in #   actual discharge data (covariates and functions #   are defined based on standardised flow values) covar_values <- data.frame(   spawning_discharge = runif(30, min = 0.5, max = 2),   spawning_variability = runif(30, min = 0.3, max = 3),   water_level_change = rpois(30, lambda = 1),   average_daily_discharge = exp(rnorm(30, sd = 2)) )  # simulate sims <- simulate(   popdyn,   nsim = 100,   args = list(     add_remove_post = list(n = c(0, 0)),         # remove no individuals this time     covariates = format_covariates(x = covar_values), # pass formatted covariate values     environmental_stochasticity = list(transform_survival)   ) )  # plot the simulated trajectories plot(sims, col = alpha(\"#2171B5\", 0.4)) # all adults plot(subset(sims, subset = 3:30), col = alpha(\"#2171B5\", 0.4)) # ages 5 and above plot(subset(sims, subset = 5:30), col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/macperch_example.html","id":"summarising-model-outputs","dir":"Articles","previous_headings":"","what":"Summarising model outputs","title":"Population dynamics of Macquarie perch","text":"model developed can used forecast Macquarie perch population dynamics time scale (e.g., years, decades). One application generation accurate predictions population dynamics relatively short time scales (1 2 years). Generating accurate predictions challenging, even short timescales, requires reliable estimates initial conditions future covariates. Applications type can use direct outputs simulation, using replicate trajectories characterise distribution possible states short time scales. alternative application comparison hypothetical scenarios longer time scales. approach emphasises relative changes population size structure, accuracy less important relative differences among scenarios. Applications type require summaries population trajectories long time scales. Examples summaries include extinction quasi-extinction risk, minimum observed population size, effective population size appropriate genetic information available. section demonstrate calculations several metrics, noting bespoke metrics applicable many situations. common simple summary metric extinction quasi-extinction risk, probability population fall zero individuals (extinction) specified threshold (quasi-extinction). example focus quasi-extinction general. rationale behind quasi-extinction , threshold, population unable recover sufficiently viable future. threshold typically assumed reflect point inbreeding becomes prevalent. population modelling terms, quasi-extinction risk proportion replicate trajectories fall given threshold time step. can calculated following function: function can used explore many different outputs: numbers indicate relatively low risk falling threshold population sizes population level highlight moderate risk extinction older individuals (21-30 years) 30 year modelled time period. general output builds concept quasi-extinction extends consider range thresholds. information can captured risk curve presents probability falling given threshold simulated time period. output can calculated following function, uses calculate_quasi_extinction function repeatedly different values threshold:  risk curve provides information likelihood hitting given population size point time. information can also presented abundance population likely reach fixed probability. example, can useful state abundance population reach 50 %, 80 %, 95 % probability. information can extracted risk curve following code:","code":"# calculate proportion of trajectories falling below a given threshold #   in any time step. By default, all population classes are included #   but `subset` can be used to select specific classes calculate_quasi_extinction <- function(popsim, threshold, subset = NULL, include = FALSE) {    # is a subset required?   if (!is.null(subset))     popsim <- subset(popsim, subset = subset)    # sum population abundances over all remaining classes   popsim <- apply(popsim, c(1, 3), sum)    # do we want to include the threshold value in the check?   if (include)     threshold <- threshold + 1e-5    # is a trajectory below a threshold?   threshold_check <- apply(popsim, 1, function(x) any(x < threshold))    # return proportion below threshold   #   (mean of binary values is the proportion equal to 1)   mean(threshold_check)  } # probability of 10 or fewer adults calculate_quasi_extinction(sims, threshold = 10, subset = 3:30, include = TRUE) ## [1] 0 # probability of 1000 or fewer individuals calculate_quasi_extinction(sims, threshold = 1000, include = TRUE) ## [1] 1 # probability of extinction of very old individuals calculate_quasi_extinction(sims, threshold = 0, subset = 21:30, include = TRUE) ## [1] 0.1 # function to calculate quasi-extinction risk for multiple thresholds calculate_risk <- function(popsim, min, max, n = 1000, subset = NULL, include = TRUE) {    # create a sequence of threshold values   thresh_seq <- seq(min, max, length = n)    # calculate risk across the entire sequence and return   #   a data.frame with threshold and risk values   data.frame(     threshold = thresh_seq,     risk = sapply(       thresh_seq,       calculate_quasi_extinction,       popsim = popsim,       subset = subset,       include = include     )   )  }  # calculate risk curve for thresholds from 0 to 10000 risk_calc <- calculate_risk(sims, min = 0, max = 1000, subset = 3:30)  # this can be plotted plot(risk ~ threshold, data = risk_calc, xlab = \"Threshold population size (adult abundance)\", ylab = \"Quasi-extinction probability\", las = 1, bty = \"l\", type = \"l\", lwd = 2, col = alpha(\"#2171B5\", 0.9), ylim = c(0, 1)) # function to calculate threshold abundance reached with probability = prob calculate_threshold <- function(risk, threshold, prob = 0.8) {    # find the rows in risk nearest to prob   idx <- sapply(prob, function(x) which.min(abs(risk - x)))    # then pull out and return these threshold values   threshold[idx]  }  # calculate these thresholds probs <- c(0.5, 0.8, 0.95) thresh <- calculate_threshold(risk_calc$risk, risk_calc$threshold, prob = probs)  # plot these on the risk curve plot(risk ~ threshold, data = risk_calc, xlab = \"Threshold population size (adult abundance)\", ylab = \"Quasi-extinction probability\", las = 1, bty = \"l\", type = \"l\", lwd = 2, col = alpha(\"#2171B5\", 0.9), ylim = c(0, 1)) col_pal <- c(\"#67001F\", \"#D6604D\", \"#FDDBC7\") for (i in seq_along(thresh)) {   lines(c(thresh[i], thresh[i]), c(-0.2, probs[i]), col = col_pal[i], lwd = 2, lty = 2)   lines(c(-100, thresh[i]), c(probs[i], probs[i]), col = col_pal[i], lwd = 2, lty = 2)   text(x = thresh[i], y = (probs[i] / 2), round(thresh[i]), pos = 4) }"},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Modelling metapopulations","text":"aae.pop built-method define metapopulation multiple populations. based -general definition metapopulation: populations species connected dispersal. Defining metapopulation requires dynamics objects multiple populations, structure defines movements populations, dispersal object, new class object used specify detail movements populations. vignette introduces structure dispersal objects explains population processes (e.g., demographic stochasticity) handled metapopulations.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"defining-a-metapopulation","dir":"Articles","previous_headings":"","what":"Defining a metapopulation","title":"Modelling metapopulations","text":"Simulating metapopulation dynamics similar basic simulate approach outlined Getting started vignette. difference population matrix expanded include multiple populations movements among populations. section start highly simplified example building metapopulation scratch introduce methods aae.pop streamline process realistic population models. First, define simplistic two-class model: assume two separate populations underlying vital rates (defined popmat_simple), possible build four-class model two classes population 1 another two classes population 2: matrix defines transitions four classes (two classes two populations), currently keeps transitions within populations. Following columns move rows rule aae.pop, metapop_simple matrix defines transitions class 1 class 2, class 2 classes 1 2, class 3 class 4, class 4 classes 3 4: Adding dispersal, movement two populations, requires transitions class 1 2 class 3 4, vice versa. example, dispersal might feature second class (adults), case individuals move class 2 class 4. movements defined cells [2, 4] [4, 2] metapop_simple:  plot sums populations, often interest considering species- metapopulation-level abundances. aae.pop built-subset method, means ’s possible separate two populations, recalling population 1 classes 1 2 population 2 classes 3 4 population vector:   illustrates highly simplified metapopulation model, highlighting main steps construction: define population dynamics separate population, define dispersal among populations, account effects dispersal within-population vital rates. following sections outline steps generalised aae.pop deal realistically complex models.","code":"popmat_simple <- matrix(   c(     0, 2,       # reproduction of 10 new individuals per adult (female)     0.45, 0.15  # move from class 1 to class 2 with 0.8 probability,                 # survive in class 2 with 0.25 probability   ),   nrow = 2,   byrow = TRUE ) # setup a matrix with four classes and all elements equal to zero metapop_simple <- matrix(0, nrow = 4, ncol = 4)  # fill the first population's vital rates #   (top two rows, two left-hand columns) metapop_simple[1:2, 1:2] <- popmat_simple  # repeat for the second population, this time #   filling the bottom right square metapop_simple[3:4, 3:4] <- popmat_simple ##      [,1] [,2] [,3] [,4] ## [1,] 0.00 2.00 0.00 0.00 ## [2,] 0.45 0.15 0.00 0.00 ## [3,] 0.00 0.00 0.00 2.00 ## [4,] 0.00 0.00 0.45 0.15 # allow 30 % of surviving adults to move between populations #   (columns move to rows, so population 1 to 2 is in [4, 2] and #    population 2 to 1 is in [2, 4]) metapop_simple[4, 2] <- 0.3 * metapop_simple[2, 2] metapop_simple[2, 4] <- 0.3 * metapop_simple[4, 4]  # this 30 % needs to be removed from the adults that survive #   and remain within the same population metapop_simple[2, 2] <- metapop_simple[2, 2] - metapop_simple[4, 2] metapop_simple[4, 4] <- metapop_simple[4, 4] - metapop_simple[2, 4]  # what happens if we simulate from this? sims <- simulate(dynamics(metapop_simple), nsim = 100) plot(sims, col = alpha(\"#2171B5\", 0.4)) pop1_sims <- subset(sims, 1:2) pop2_sims <- subset(sims, 3:4) plot(pop1_sims, col = alpha(\"#2171B5\", 0.4)) plot(pop2_sims, col = alpha(\"#2171B5\", 0.4))"},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"structure","dir":"Articles","previous_headings":"Defining a metapopulation","what":"Structure","title":"Modelling metapopulations","text":"structure metapopulation defines populations connected. Structure captured aae.pop matrix zeros ones denote links two populations. matrix one row one column population, follows columns move rows rule population matrix. example, 1 second row, first column, indicates individuals population 1 can move population 2. 1 first row, second column denotes reverse movement (population 2 population 1). simplistic example , structure look like: structure can defined : Increasing number populations direct extension approach. five populations connected dispersal, structure look like: realistic structure might consider five populations possible connections, might look like: example, individuals population 1 move populations 3 4, individuals population 2 move populations 1 3, individuals population 4 move populations 2 5. Individuals populations 3 5 never move populations.","code":"##      [,1] [,2] ## [1,]    0    1 ## [2,]    1    0 structure_simple <- matrix(c(0, 1, 1, 0), nrow = 2) ##      [,1] [,2] [,3] [,4] [,5] ## [1,]    0    1    1    1    1 ## [2,]    1    0    1    1    1 ## [3,]    1    1    0    1    1 ## [4,]    1    1    1    0    1 ## [5,]    1    1    1    1    0 ##      [,1] [,2] [,3] [,4] [,5] ## [1,]    0    1    0    0    0 ## [2,]    0    0    0    1    0 ## [3,]    1    1    0    0    0 ## [4,]    1    0    0    0    0 ## [5,]    0    0    0    1    0"},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"dispersal","dir":"Articles","previous_headings":"Defining a metapopulation","what":"Dispersal","title":"Modelling metapopulations","text":"Defining structure metapopulation first step towards simulating metapopulation dynamics. However, definition structure biologically vague. specifies populations connected direction connections, doesn’t specify classes within populations moving frequently. dispersal objects specify probability transition specific source receiver classes, whether transitions density dependent, stochasticity transitions. dispersal objects one-directional, means separate dispersal object required link structure matrix. Using simplistic, two-class example, adults moving directions two populations, dispersal objects specified : kernel matrix two rows two columns, 0.3 bottom-right corner specifies 30 % surviving adults move one population another. argument proportion determines whether 30 % moving individuals proportion surviving adults absolute value. Setting proportion = TRUE addresses situation 30 % moving adults taken total pool surviving adults, thereby reducing within-population survival 30 %. setup sufficient specify one-direction movement populations; additional dispersal term required specify reverse transition. aae.pop, dispersal terms can combined list, stored column-major order following metapopulation structure. means one dispersal object must provided link structure, working columns left--right (.e., links column 1, links column 2, ). simplistic example, dispersal term can used links: example presents simplified dispersal setup. aae.pop supports complex features stochasticity density dependence transitions. two extensions discussed briefly .","code":"kern <- matrix(c(0, 0, 0, 0.3), nrow = 2) dispersal_simple <- dispersal(kernel = kern, proportion = TRUE) dispersal_simple <- list(dispersal_simple, dispersal_simple)"},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"Defining a metapopulation","what":"Putting it all together","title":"Modelling metapopulations","text":"Together, popmat_simple, structure_simple, dispersal_simple sufficient characterise metapopulation dynamics metapop_simple. metapopulation function ties three elements together: metapopulation defined metapopulation_simple identical defined metapop_simple, : metapopulation_simple defined way, simulating population dynamics identical population model aae.pop:   complicated metapopulation structure might consider population introduced Getting started vignette, five age classes. Coupling five-population structure shown demonstrates realistic metapopulation. Note specifying metapopulation manually require matrix 25 rows 25 columns, dispersal proportional change survival calculated individually. Using aae.pop still takes lines code many calculations now handled automatically:  five populations, five classes, simulated values now 25 total classes. stored order five populations defined dynamics argument metapopulation, classes 1 5 first population, 6 10 second population, . can extracted plotted subset function:   plots illustrate effects metapopulation dynamics: population 1 loses individuals gains decline, whereas population 5 gains individuals upward trajectory result.","code":"# create a population dynamics object from the population matrix dynamics_simple <- dynamics(popmat_simple)  # turn this into a metapopulation metapopulation_simple <- metapopulation(   structure = structure_simple,   dynamics = list(dynamics_simple, dynamics_simple), # both populations have identical rates   dispersal = dispersal_simple ) all.equal(metapop_simple, metapopulation_simple$matrix) ## [1] TRUE sims <- simulate(metapopulation_simple, nsim = 100) plot(subset(sims, 1:2), col = alpha(\"#2171B5\", 0.4), main = \"Population 1\") plot(subset(sims, 3:4), col = alpha(\"#2171B5\", 0.4), main = \"Population 2\") # define population matrix popmat <- rbind(   c(0,    0,    2,    4,    7),  # reproduction from 3-5 year olds   c(0.25, 0,    0,    0,    0),  # survival from age 1 to 2   c(0,    0.45, 0,    0,    0),  # survival from age 2 to 3   c(0,    0,    0.70, 0,    0),  # survival from age 3 to 4   c(0,    0,    0,    0.85, 0)   # survival from age 4 to 5 )  # define metapopulation structure mp_str <- matrix(0, nrow = 5, ncol = 5) mp_str[1, 2] <- mp_str[3, 2] <- mp_str[5, 4] <- mp_str[4, 1] <- mp_str[3, 1] <- mp_str[2, 4] <- 1  # define dispersal, assume all dispersal links are the same mp_kern <- matrix(0, nrow = 5, ncol = 5) mp_kern[3, 4] <- mp_kern[4, 5] <- 0.2  # adults can move once per year with 20 % probability mp_disp <- dispersal(kernel = mp_kern, proportion = TRUE)  # define metapopulation mp <- metapopulation(   structure = mp_str,   dynamics = lapply(1:5, function(x) dynamics(popmat)),   # five populations, all identical rates   dispersal = lapply(1:6, function(x) mp_disp)  # six transitions in mp_str, all identical )  # simulate sims <- simulate(mp, nsim = 100)  # plot plot(sims, col = alpha(\"#2171B5\", 0.4), main = \"All populations\") plot(subset(sims, 1:5), col = alpha(\"#2171B5\", 0.4), main = \"Population 1\") plot(subset(sims, 21:25), col = alpha(\"#2171B5\", 0.4), main = \"Population 5\")"},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"what-happens-to-within-population-processes","dir":"Articles","previous_headings":"","what":"What happens to within-population processes?","title":"Modelling metapopulations","text":"metapopulation function preserves within-population processes, density dependence, environmental demographic stochasticity, covariate effects (see one complication covariates). processes operate within populations, largely separate dispersal. Dispersal can subject among-population density dependence stochasticity; described . Within-population processes preserved using mask/function approach used demographic processes, described Including processes vignette. set masks created population (blocks block-diagonal matrix), functions population coupled appropriate mask. example flexibility mask/function approach. -product setup processes (exception dispersal) assumed independent populations. example, density dependence consider number individuals currently population take account overall metapopulation abundance. level detail required, metapopulation function still used prepare metapopulation-level elements (e.g., metapopulation matrix, process functions), additional processes added metapopulation-level masks functions (e.g., new call density_dependence).","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"covarissues","dir":"Articles","previous_headings":"What happens to within-population processes?","what":"A complication: covariates","title":"Modelling metapopulations","text":"metapopulation function designed make metapopulation dynamics similar possible single-population dynamics, takes full advantage methods simulate (relatively) fast flexible models. One complication simulate explicitly allow separate covariate sequences population. relatively common scenario given metapopulations typically span multiple spatial locations, section illustrates possible workaround. additional example approach included metapopulation documentation (accessible typing ?metapopulation R console). elegant solution focus future development aae.pop. Using simplified, two-population example , workaround involves combining two sequences covariates single matrix (data.frame), subsetting combined matrix within covariates functions individual population.  example uses named data.frame store covariate sequences populations approach use number covariates form subsetting indexing covariates within covariate functions.","code":"# define two covariate sequences and combine them into a data.frame covar_seq1 <- runif(20, min = 0.5, max = 1.0) covar_seq2 <- runif(20, min = 0.75, max = 1.0) covar_seq <- data.frame(pop1 = covar_seq1, pop2 = covar_seq2)  # define covariate responses for each population, pulling out #   the appropriate covariate sequence in each covar_fn1 <- function(mat, x) {   mat * x$pop1 } covar_fn2 <- function(mat, x) {   mat * x$pop2 }  # define the covariates object for each population covar1 <- covariates(masks = transition(popmat_simple), funs = covar_fn1) covar2 <- covariates(masks = transition(popmat_simple), funs = covar_fn2)  # create a population dynamics object for each population dynamics_simple1 <- dynamics(popmat_simple, covar1) dynamics_simple2 <- dynamics(popmat_simple, covar2)  # turn this into a metapopulation metapopulation_simple <- metapopulation(   structure = structure_simple,   dynamics = list(dynamics_simple1, dynamics_simple2),   dispersal = dispersal_simple )  # simulate sims <- simulate(   metapopulation_simple,   nsim = 100,   args = list(covariates = format_covariates(covar_seq)) )  # plot plot(sims, col = alpha(\"#2171B5\", 0.4), main = \"Population-specific covariates\")"},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"advanceddispersal","dir":"Articles","previous_headings":"","what":"More on dispersal","title":"Modelling metapopulations","text":"dispersal function, used define class-specific movements two populations, also allows density dependence stochasticity movements. two processes useful account scenarios individual decisions move depend number individuals source receiving population, outcomes movement decisions stochastic due , example, mortality risk movement. Specification density dependence stochasticity dispersal uses mask/function approach demonstrated Including processes vignette.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"stochasticity","dir":"Articles","previous_headings":"More on dispersal","what":"Stochasticity","title":"Modelling metapopulations","text":"highly likely dispersal outcomes stochastic due unpredictable movements individuals increased mortality following dispersal. Stochasticity supported definition dispersal objects mask/function pair identifies relevant classes form stochasticity. Extending simplified example , might look like:","code":"# define a mask that is TRUE whenever the dispersal kernel is non-zero stoch_mask <- kern > 0  # define a stochastic dispersal function (small change in probability) stoch_fun <- function(x) {   rmultiunit(length(x), mean = x, sd = 0.05) }  # using the kernel defined earlier (30 % probability of adults moving) dispersal_simple <- dispersal(   kernel = kern,   stochasticity_masks = stoch_mask,   stochasticity_funs = stoch_fun,   proportion = TRUE )  # dispersal is one-directional, so need one dispersal object for each population dispersal_simple <- list(dispersal_simple, dispersal_simple)  # define metapopulation using the dynamics and structure objects defined above metapopulation_simple <- metapopulation(   structure = structure_simple,   dynamics = list(dynamics_simple, dynamics_simple),   dispersal = dispersal_simple )  # simulate sims <- simulate(metapopulation_simple, nsim = 100)  # plot plot(sims, col = alpha(\"#2171B5\", 0.4), main = \"Stochastic dispersal\")"},{"path":"https://aae-stats.github.io/aae.pop/articles/metapopulations.html","id":"density-dependence","dir":"Articles","previous_headings":"More on dispersal","what":"Density dependence","title":"Modelling metapopulations","text":"Density dependence might influence dispersal individual decisions move remain based number individuals current (source) future (destination) population. broadly, abundances source destination populations might influence survival outcomes following dispersal due levels competition density-dependent stressors (e.g., disease). types processes can included metapopulation model density_masks density_funs arguments dispersal. current implementation density-dependent dispersal linked entire metapopulation vector, can depend abundances sub-populations. downside approach indexing vector done manually definition density_funs. indexing depends order populations within metapopulation (defined dynamics argument metapopulation), recalling population one element class. example might illustrate inclusion density-dependent dispersal clearly:","code":"# define a mask that is TRUE whenever the dispersal kernel is non-zero #   (this is the same as for stochasticity and this mask  #    could be used for both) dd_mask <- kern > 0  # define Ricker type density dependence based on the abundance in the #    destination population (recall n is a vector of two classes per #    population, so elements 1 and 2 are population 1 and elements #    3 and 4 are population 2) dd_fun1 <- function(x, n) {   # dispersing from population 1 to 2   x * exp(1 - sum(n[3:4]) / 20) / exp(1)  } dd_fun2 <- function(x, n) {   # dispersing from population 2 to 1   x * exp(1 - sum(n[1:2]) / 20) / exp(1) }  # using the kernel defined earlier (30 % of surviving adults moving), #    add density masks and functions for each population dispersal_simple1 <- dispersal(   kernel = kern,   density_masks = dd_mask,   density_funs = dd_fun1,   proportion = TRUE ) dispersal_simple2 <- dispersal(   kernel = kern,   density_masks = dd_mask,   density_funs = dd_fun2,   proportion = TRUE )  # combine the dispersal objects for both populations dispersal_simple <- list(dispersal_simple1, dispersal_simple2)  # define metapopulation using the dynamics and structure objects defined above metapopulation_simple <- metapopulation(   structure = structure_simple,   dynamics = list(dynamics_simple, dynamics_simple),   dispersal = dispersal_simple )  # simulate sims <- simulate(metapopulation_simple, nsim = 100)  # plot plot(sims, col = alpha(\"#2171B5\", 0.4), main = \"Density-dependent dispersal\")"},{"path":"https://aae-stats.github.io/aae.pop/articles/multiple_species.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Models of interacting species","text":"aae.pop two built-functions define population dynamics multiple, interacting species: pairwise_interaction multispecies. two functions can used create extended dynamics object, possible simulate dynamics species simultaneously. Incorporating multiple species differs single-population metapopulation model primarily different species longer assumed matrix structure (e.g., can differ number classes). Note approach also used multipopulation models single species increased flexibility required. important keep mind multispecies models difficult parameterise due lack knowledge species interactions, especially interactions among specific age size classes. addition, complex multispecies models (e.g., including covariates demographic processes) tested extensively functions methods likely change following testing.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/multiple_species.html","id":"defining-species-interactions","dir":"Articles","previous_headings":"","what":"Defining species interactions","title":"Models of interacting species","text":"first requirement multispecies population model definition interactions among species. Without interactions, simulated population dynamics identical simulated separate, single-species models. aae.pop assumes interactions pairwise, , species interactions depend presence abundance third species. Given difficulty estimating pairwise interactions species, unlikely models higher-order interactions reliable. Species interactions can defined pairwise_interaction function. function uses mask/function approach introduced Including processes vignette. pairwise_interaction function requires two additional arguments: population dynamics object target population (species) source population (species). , target refers species whose vital rates influenced abundances source species. Building simple model introduced Getting started vignette, consider three species system following population matrices: can define population dynamics objects species , , define interactions species 1 3 species 2 3:","code":"# define population matrices for three species sp1_mat <- rbind(   c(0,    0,    2,    4,    7),  # reproduction from 3-5 year olds   c(0.25, 0,    0,    0,    0),  # survival from age 1 to 2   c(0,    0.45, 0,    0,    0),  # survival from age 2 to 3   c(0,    0,    0.70, 0,    0),  # survival from age 3 to 4   c(0,    0,    0,    0.85, 0)   # survival from age 4 to 5 ) sp2_mat <- rbind(   c(0,    0,    4),  # reproduction from 3 year olds   c(0.25, 0,    0),  # survival from age 1 to 2   c(0,    0.45, 0)   # survival from age 2 to 3 ) sp3_mat <- rbind(   c(0,    0,    2,    4,    7,   10),  # reproduction from 3-6 year olds   c(0.25, 0,    0,    0,    0,    0),  # survival from age 1 to 2   c(0,    0.45, 0,    0,    0,    0),  # survival from age 2 to 3   c(0,    0,    0.70, 0,    0,    0),  # survival from age 3 to 4   c(0,    0,    0,    0.85, 0,    0),  # survival from age 4 to 5   c(0,    0,    0,    0,    0.75, 0)   # survival from age 5 to 6 ) # define population dynamics objects for each species sp1_dyn <- dynamics(sp1_mat) sp2_dyn <- dynamics(sp2_mat) sp3_dyn <- dynamics(sp3_mat)  # define multispecies interactions as masks/functions # - species 1 influencing transition probabilities of species 3 mask_1v3 <- transition(sp3_mat)  # basic Beverton-Holt function fun_1v3 <- function(x, n) {   # n is the population vector of the source population (sp 1)   x / (1 + x * sum(n[3:5]) / 100) # focus on adults }  # - species 3 influencing reproduction of species 2 mask_3v2 <- reproduction(sp2_mat, dims = 3)  # basic Ricker function fun_3v2 <- function(x, n) {   # n is the population vector of the source population (sp 3)   x * exp(1 - sum(n[1:2]) / 50) / exp(1) # focus on juveniles }  # combine masks and functions into pairwise_interaction objects sp_int1v3 <- pairwise_interaction(sp3_dyn, sp1_dyn, mask_1v3, fun_1v3) sp_int3v2 <- pairwise_interaction(sp2_dyn, sp3_dyn, mask_3v2, fun_3v2)"},{"path":"https://aae-stats.github.io/aae.pop/articles/multiple_species.html","id":"simulating-multispecies-dynamics","dir":"Articles","previous_headings":"","what":"Simulating multispecies dynamics","title":"Models of interacting species","text":"pairwise interactions defined, multispecies function can used compile dynamics object can passed simulate. Note function sees pairwise interaction objects, multispecies dynamics object include species interact directly another species. Simulation multispecies dynamics similar single-species case. key exceptions initial conditions covariates (provided) must lists, one element species. single set initial conditions still work species number classes, case species assumed initial conditions. Providing species-level arguments processes currently possible focus future development. simplest case, multispecies dynamics can simulated default initial conditions additional arguments: case, simulate function returns list one element species. individual elements can handled way single-species models, aae.pop can also work directly multispecies output. example, plot function multispecies simulation object plot species separate plots default, takes optional argument specifies species plot:","code":"# compile a multispecies dynamics object multisp_dyn <- multispecies(sp_int1v3, sp_int3v2)  # simulate sims <- simulate(multisp_dyn, nsim = 100) # plot plot(sims, which = 1, col = alpha(\"#2171B5\", 0.4), main = \"Species 1\") # plot plot(sims, which = 2, col = alpha(\"#2171B5\", 0.4), main = \"Species 2\") # plot plot(sims, which = 3, col = alpha(\"#2171B5\", 0.4), main = \"Species 3\")"},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Comparing scenarios with population models","text":"common application population models comparison scenarios based population outcomes. Examples include predicting population trajectories different scenarios climate change, comparing ranking competing management scenarios, predicting consequences different ecological hypotheses. example uses simplified model population dynamics demonstrate comparison multiple scenarios, well several methods speed computation simulating many scenarios. detailed exploration approach outlined (Yen et al. 2021) (Yen et al. 2022).","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"a-simple-population-model","dir":"Articles","previous_headings":"","what":"A simple population model","title":"Comparing scenarios with population models","text":"example focus simplified model population dynamics tractability. example consider four distinct populations (.e., separate populations, metapopulation) species identical average vital rates populations. species assumed vital rates demographic processes similar example species Including processes vignette: -complex processes required simulate scenarios . One consideration fishing regulations change time, might captured add_remove_post function proportion number individuals removed changes time: scenarios also consider habitat restoration multiple sites. effects habitat restoration can captured covariates process alters vital rates based current habitat extent:","code":"# the population matrix popmat <- rbind(   c(0,    0,    10,   15,    20),  # reproduction from 3-5 year olds   c(0.50, 0,    0,    0,     0),   # survival from age 1 to 2   c(0,    0.65, 0,    0,     0),   # survival from age 2 to 3   c(0,    0,    0.85, 0,     0),   # survival from age 3 to 4   c(0,    0,    0,    0.9,   0)    # survival from age 4 to 5 )  # add some demographic stochasticity demostoch_mask <- all_classes(popmat) # affects all classes demostoch_fn <- function(x) {   rpois(length(x), lambda = x) } demostoch <- demographic_stochasticity(   masks = demostoch_mask,   funs = demostoch_fn )  # and some environmental stochasticity reproduction_mask <- reproduction(popmat, dims = 3:5) # only ages 3-5 reproduce reproduction_fn <- function(x) {   rpois(length(x), lambda = x) } transition_mask <- transition(popmat) # all classes this time transition_fn <- function(x) {      # add a random deviation to x   deviation <- runif(length(x), min = -0.1, max = 0.1)   x <- x + deviation      # make sure the result isn't negative or greater than 1   x[x < 0] <- 0   x[x > 1] <- 1      # return the value   x    } envstoch <- environmental_stochasticity(   masks = list(reproduction_mask, transition_mask),   funs = list(reproduction_fn, transition_fn) )  # specify a Ricker model for density dependence dd <- density_dependence(   masks = reproduction(popmat, dims = 3:5), # only adults reproduce   funs = ricker(k = 40, exclude = 1:2)      # set k based on adult abundances ) # specify a function to remove a set number of adults in any given year, #   with an argument that can be changed through time to incorporate #   changing scenarios removals_fn <- function(n, remove) {      # add some stochasticity in the number of removals   remove <- rpois(1, lambda = remove)      # check that there are enough individuals to remove,   #   only remove up to sum(n) individuals   if (remove > sum(n))     remove <- sum(n)      # work out which age classes to remove, sampled   #   randomly up to the total available in each   #   age class   n_available <- rep(3:5, times = n)   removal_idx <- sample.int(     length(n_available), size = remove, replace = FALSE   )      # expand this into a vector of removals by age class   remove <- table(n_available[removal_idx])   remove_expanded <- rep(0, 3)   names(remove_expanded) <- as.character(3:5)   remove_expanded[names(remove)] <- remove    # and return updated abundances   n - remove_expanded    }  # collate this into a single add_remove_post object,  #   focusing on adults add_remove <- add_remove_post(   masks = all_classes(popmat, dims = 3:5), # want to focus on adults   funs = removals_fn ) # effects of habitat condition on reproduction #    reductions up to 10 % if habitat is non-existent, #    minimal reductions if habitat reaches 50 % of  #    its maximum extent reproduction_effects <- function(mat, x, alpha = 0.1, beta = 4, ...) {    # define a nonlinear effect of habitat   scale_factor <- 1 / (1 + alpha * exp(- beta * x))    # return re-scaled survival values   mat * scale_factor  }  # effects of habitat condition on survival #    minimal reductions unless habitat falls #    below 30 % of its expected extent, up to #    a 5 % reduction with non-existent habitat survival_effects <- function(mat, x, alpha = 0.05, beta = 10, ...) {    # define a nonlinear effect of habitat   scale_factor <- 1 / (1 + alpha * exp(- beta * x))    # return re-scaled survival values   mat * scale_factor  }  # define masks covar_masks <- list(   reproduction(popmat),   transition(popmat) )  # link functions to masks covar_funs <- list(   reproduction_effects,   survival_effects )  # collate into a single object covars <- covariates(   masks = covar_masks,   funs = covar_funs )"},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"defining-scenarios","dir":"Articles","previous_headings":"","what":"Defining scenarios","title":"Comparing scenarios with population models","text":"example considers set scenarios based combinations four generalised management actions implemented across four populations (four distinct locations). actions : increase habitat extent 40 % location least habitat increase habitat extent 15 % two locations least habitat regulate enforce complete ban fishing two locations reduce fishing pressure regulation partial enforcement locations first second actions alternatives one another, third fourth actions. Therefore, 9 possible combinations actions : habitat restoration one location, fishing regulation two locations habitat restoration one location, fishing regulation locations habitat restoration two locations, fishing regulation two locations habitat restoration two locations, fishing regulation locations habitat restoration one location, fishing regulation habitat restoration two locations, fishing regulation habitat restoration, fishing regulation two locations habitat restoration, fishing regulation locations habitat restoration, fishing regulation four actions hypothetical can assumed similar financial costs. Therefore, purpose scenario testing case identify benefits different combinations actions relative one another relative taking action. different actions can implemented aae.pop functions convert actions sequences covariates arguments influence covariates density_dependence_n processes simulate. habitat restoration, function might look like: incorporate scenarios fishing regulation simply requires args element add_remove_post specifies average number fish removed per year. case, unregulated fishing assumed remove 50 fish per year site, partial regulation reducing 25 fish removed per year.","code":"# function to define habitat extent including restoration effects restore <- function(n, amount, current, ntime) {      # pull out the worst n sites   idx <- order(current, decreasing = FALSE)[seq_len(n)]    # create sequences of habitat extent at all sites   current <- do.call(     rbind,     lapply(seq_len(ntime), function(x) current)   )      # add habitat over a period of 5 years, up to `amount`   add <- c(seq(0, amount, length = 5), rep(amount, ntime - 5))    # update sequences of habitat extent in the worst n sites     current[, idx] <- sweep(     current[, idx, drop = FALSE],     1,     add,     \"+\"   )      # return   current    }"},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"simulating-many-scenarios","dir":"Articles","previous_headings":"","what":"Simulating many scenarios","title":"Comparing scenarios with population models","text":"nine possible combinations actions (nine management options) four populations. Simulating population dynamics case requires least 36 simulations. section demonstrate simplest way set simulate dynamics many scenarios. following section present several methods speed computation large cases (e.g., thousands even millions scenarios).","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"setting-up-the-model","dir":"Articles","previous_headings":"Simulating many scenarios","what":"Setting up the model","title":"Comparing scenarios with population models","text":"36 simulations, taking perhaps seconds, real need speed simulations. case, complexity setting defining scenarios interpreting outputs. Set requires simulations four populations management actions. following code , using calculate_quasi_extinction function defined Macquarie perch example summarise population trajectories: simulation approach demonstrated relatively comprehensive, considering every feasible combination actions simulating 1000 replicate trajectories population scenario. Extensions might explore additional sources variation, using range initial conditions including variation covariates (e.g., weather climate). particular example, fishing action also static, regulate_two action always regulating two populations (locations 1 2).","code":"# set up some basic parameters npop <- 4      # how many populations? ntime <- 50    # how many years to simulate? nsim <- 100   # how many replicates?  # simulate current habitat extent (between 20 % and 60 %) habitat_extent <- runif(n = npop, min = 0.2, max = 0.6)  # define a population model for each of the four populations popdyn <- lapply(   seq_len(npop),   function(i) dynamics(     envstoch(popmat),   # alter the matrix slightly for each population     envstoch,     demostoch,     dd,     add_remove,     covars   ) )  # define initial abundances in each population initial_abundance <- replicate(   npop, rpois(5, lambda = c(100, 50, 25, 10, 5)) )  # define the habitat restoration actions habitat <- rbind(   \"restore_none\" = c(n = 0, amount = 0),   # no sites restored   \"restore_one\" = c(n = 1, amount = 0.40), # one site increased by 40 %   \"restore_two\" = c(n = 2, amount = 0.15)  # two sites each increased by 15 % )  # define the fishing regulation actions fishing <- rbind(   \"regulate_none\" = c(remove = c(50, 50, 50, 50)),  # baseline fishing pressure   \"regulate_two\" = c(remove = c(0, 0, 50, 50)),     # complete halt at two sites   \"regulate_all\" = c(remove = c(25, 25, 25, 25))    # reduction at all sites )  # define all combinations of actions scenarios <- expand.grid(   habitat = rownames(habitat),   fishing = rownames(fishing) )  # loop through each scenario quasi_ext <- matrix(NA, nrow = nrow(scenarios), ncol = npop)  # empty matrix to store extinction risk estimates for (i in seq_len(nrow(scenarios))) {      # pull out the relevant actions   hab_tmp <- habitat[scenarios$habitat[i], ]   fish_tmp <- fishing[scenarios$fishing[i], ]      # define habitat extent taking into account restoration   extent_tmp <-restore(     n = hab_tmp[1],     amount = hab_tmp[2],     current = habitat_extent,     ntime = ntime   )      # the populations are independent, so can be run simultaneously    #   with lapply, mapply, or with a for loop   sims <- list()   for (j in seq_along(popdyn)) {     sims[[j]] <- simulate(       popdyn[[j]],       nsim = nsim,       init = initial_abundance[, j],       args = list(         covariates = format_covariates(extent_tmp[, j]),         add_remove_post = list(remove = fish_tmp[j])       )     )       }      # summarise the trajectories   quasi_ext[i, ] <- sapply(     sims,      calculate_quasi_extinction,     threshold = 10,     # the quasi-extinction level     subset = 3:5,       # focus on adults     include = TRUE      # less than or equal to threshold   )    }"},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"interpreting-the-outputs","dir":"Articles","previous_headings":"Simulating many scenarios","what":"Interpreting the outputs","title":"Comparing scenarios with population models","text":"quasi-extinction estimates can interpreted directly population nine scenarios: results highlight interesting pattern. Fishing regulation clearly major impact population trajectories, complete ban fishing reducing extinction risk almost zero regulated populations. However, remaining (unregulated) populations still relatively high quasi-extinction risks. highlights conceptual challenge results spread multiple populations: much individual population worth? ’s possible dig additional summary statistics augment population-level estimates quasi-extinction risk: Alternatively, probability persistence (.e., avoiding extinction) can often useful output: outputs give -complete picture relative risk nine scenarios: outputs provide clearer picture relative risks different scenarios, supporting decisions based priorities single versus multiple populations. case, little justification investment habitat restoration plenty reason invest regulating fishing. focus persistence single population doesn’t distinguish two fishing actions (partial complete ban), yet focus maintaining populations indicates partial regulation across locations likely much effective strategy, reducing risk one populations become extinct. Many variants summaries exist, probabilities 2 populations persist, average extinction risk weighted measure population’s value, metrics based expected genetic functional diversity scenarios. outputs modelling approach might support recommendation right, might guide development alternative management actions, -nuanced fishing regulations extensive habitat restoration scenarios. Alternatively, model outputs might highlight flaws model construction. example, habitat restoration known effective indicated results , might indicate knowledge gaps limit current model’s applicability.","code":"##        habitat       fishing population 1 population 2 population 3 ## 1 restore_none regulate_none         0.96         0.96         0.92 ## 2  restore_one regulate_none         0.96         0.96         0.91 ## 3  restore_two regulate_none         0.96         0.96         0.93 ## 4 restore_none  regulate_two         0.00         0.00         0.92 ## 5  restore_one  regulate_two         0.00         0.00         0.92 ## 6  restore_two  regulate_two         0.00         0.00         0.91 ## 7 restore_none  regulate_all         0.08         0.04         0.06 ## 8  restore_one  regulate_all         0.07         0.05         0.06 ## 9  restore_two  regulate_all         0.07         0.05         0.05 ##   population 4 ## 1         0.93 ## 2         0.94 ## 3         0.94 ## 4         0.94 ## 5         0.94 ## 6         0.94 ## 7         0.06 ## 8         0.06 ## 9         0.04 # average quasi-extinction risk average_risk <- apply(quasi_ext, 1, mean)  # geometric mean quasi-extinction risk geom_ave_risk <- apply(quasi_ext, 1, function(x) exp(mean(log(x))))  # probability that at least one population becomes (quasi) extinct one_or_more_ext <- 1 - apply(quasi_ext, 1, function(x) prod(1 - x)) # probability of persistence for all populations under each scenario pr_persist <- 1 - quasi_ext  # probability that at least one population persists one_or_more_persist <- 1 - apply(quasi_ext, 1, prod)  # probability that all four populations persist all_persist <- apply(pr_persist, 1, prod) ##   Habitat action Fishing action Average risk Geometric average risk ## 1   restore_none  regulate_none         0.94                   0.94 ## 2    restore_one  regulate_none         0.94                   0.94 ## 3    restore_two  regulate_none         0.95                   0.95 ## 4   restore_none   regulate_two         0.46                   0.02 ## 5    restore_one   regulate_two         0.46                   0.02 ## 6    restore_two   regulate_two         0.46                   0.03 ## 7   restore_none   regulate_all         0.06                   0.06 ## 8    restore_one   regulate_all         0.06                   0.06 ## 9    restore_two   regulate_all         0.05                   0.05 ##   Pr(at least one extinct) Pr(at least one persist) Pr(all persist) ## 1                     1.00                     0.21            0.00 ## 2                     1.00                     0.22            0.00 ## 3                     1.00                     0.20            0.00 ## 4                     1.00                     1.00            0.00 ## 5                     0.99                     1.00            0.01 ## 6                     0.99                     1.00            0.01 ## 7                     0.21                     1.00            0.79 ## 8                     0.21                     1.00            0.79 ## 9                     0.20                     1.00            0.80"},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"speeding-up-simulations","dir":"Articles","previous_headings":"","what":"Speeding up simulations","title":"Comparing scenarios with population models","text":"models require many repeated simulations. section outlines two ways speed simulations comparing many scenarios. methods relatively complex set may give marginal improvements (improvement ), recommended default approaches aae.pop.","code":""},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"running-in-parallel","dir":"Articles","previous_headings":"Speeding up simulations","what":"Running in parallel","title":"Comparing scenarios with population models","text":"Importantly, simulations different scenarios entirely independent one another, makes embarrassingly parallel problem. means simulations can split run simultaneously, assuming sufficient cores memory. future future.apply R packages make easy deal embarrassingly parallel problems R. packages allow users set general problem statement evaluated future can specified (changed) actually running code. Practically, means writing one bit code can used several possible futures, including personal computer one cores, cloud compute server, large HPC system, spread across multiple nodes distributed compute system. especially useful code can developed tested local computer sent -powerful system extended model runs. One trick (easily) running embarrassingly parallel problems R use _apply statements (e.g. sapply, lapply) place loops contents loop depend previous iterations. process can slightly confusing first , simplest form, simply requires wrapping contents loop function passing function lapply sapply. R, first step wrap main steps loop function: function can passed one functions future.apply package, provides versions R’s standard apply functions work future package. example uses multisession evaluation future, work Windows Unix-like systems (including OSX), launches multiple R sessions running parallel. default number sessions launched multisession can viewed availableCores() function changed specifying workers argument multisession. generates outputs similar : quasi-extinction estimates identical example set seed. Even seed, example unlikely generate results scenarios evaluated parallel separate R sessions, introduces multiple RNG streams changes order execution scenarios. example demonstrates one way scenarios can run parallel. alternative case run internal loop (population) parallel, either leaving outer loop loop running parallel. benefits different approaches depend two things: computing setup available relative runtime step. computing setup determine many different things can run simultaneously (typically limited number cores amount memory). Relative runtime matters overhead running things parallel. overhead can slow things sufficiently benefit sometimes cost running really quick bits code parallel. general, least personal computer, running time-consuming bits code parallel best choice.","code":"# need a function that takes `scenarios` as input and #   spits out the simulation outputs run_scenario <- function(   scenario,   popdyn,   habitat,   fishing,   habitat_extent,    initial_abundance,   ntime,    nsim ) {      # pull out the relevant actions   #  scenario is now a vector with two elements, habitat and fishing   hab_tmp <- habitat[scenario[1], ]   fish_tmp <- fishing[scenario[2], ]      # define habitat extent taking into account restoration   extent_tmp <-restore(     n = hab_tmp[1],     amount = hab_tmp[2],     current = habitat_extent,     ntime = ntime   )      # the populations are independent, so can be run simultaneously    #   with lapply, mapply, or with a for loop   sims <- list()   for (j in seq_along(popdyn)) {     sims[[j]] <- simulate(       popdyn[[j]],       nsim = nsim,       init = initial_abundance[, j],       args = list(         covariates = format_covariates(extent_tmp[, j]),         add_remove_post = list(remove = fish_tmp[j])       )     )       }      # summarise the trajectories and return these values   sapply(     sims,      calculate_quasi_extinction,     threshold = 10,     # the quasi-extinction level     subset = 3:5,       # focus on adults     include = TRUE      # less than or equal to threshold   )    } # load the package library(future.apply)  # set the evaluation future, may require the R package library #   (can be viewed with .libPaths()) to be passed directly with  #   the `rscript_libs` option if using network drives plan(multisession)  # use `apply` to evaluate the run_scenario function once  #   for each scenario, running up to availableCores() #   scenarios in parallel quasi_ext_parallel <- t(future_apply(   scenarios,                    # matrix/data.frame of scenaios   MARGIN = 1,                   # margin of scenarios to iterate over, 1 is rows, 2 is columns   FUN = run_scenario,           # function to call on each row of scenarios   popdyn = popdyn,              # other arguments to FUN   habitat = habitat,   fishing = fishing,   habitat_extent = habitat_extent,    initial_abundance = initial_abundance,   ntime = ntime,    nsim = nsim,   future.seed = TRUE            # tells future that there are RNG calls in run_scenario ))  # it can be useful to reset the evaluation future, both to  #   avoid unexpected behaviour within the main R session #   and to shut down any background workers. The sequential #   evaluation is the default R behaviour (not running anything #   in parallel) plan(sequential) ##        habitat       fishing population 1 population 2 population 3 ## 1 restore_none regulate_none         0.97         0.96         0.93 ## 2  restore_one regulate_none         0.95         0.96         0.92 ## 3  restore_two regulate_none         0.96         0.96         0.93 ## 4 restore_none  regulate_two         0.00         0.00         0.91 ## 5  restore_one  regulate_two         0.00         0.00         0.91 ## 6  restore_two  regulate_two         0.00         0.00         0.92 ## 7 restore_none  regulate_all         0.06         0.04         0.05 ## 8  restore_one  regulate_all         0.07         0.05         0.06 ## 9  restore_two  regulate_all         0.06         0.03         0.06 ##   population 4 ## 1         0.94 ## 2         0.94 ## 3         0.93 ## 4         0.94 ## 5         0.92 ## 6         0.94 ## 7         0.04 ## 8         0.05 ## 9         0.05"},{"path":"https://aae-stats.github.io/aae.pop/articles/scenarios_example.html","id":"not-so-meta-populations","dir":"Articles","previous_headings":"Speeding up simulations","what":"Not-so-meta populations","title":"Comparing scenarios with population models","text":"one less-obvious option simulations multiple, independent populations: running populations single metapopulation dispersal. method computational benefits calculations within simulate vectorised, can make operations one big matrix faster repeating operations multiple, smaller matrices. However, complex method set primarily mask/function approach used aae.pop yet work neatly metapopulations. Setting metapopulation purpose requires redefinition density_dependence_n covariates processes neither set handle arguments multiple populations simultaneously. first step define base metapopulation dynamics object: second step involves redefining add_remove_post covariates processes use masks identify correct elements metapopulation vector (now 20 elements, 5 population) use functions select correct arguments population. latter approach also demonstrated Metapopulation vignette help file metapopulations function. final step update metapopulation dynamics object new density_dependence_n covariates objects use simulate (meta)population trajectories scenario. , quasi-extinction estimates can interpreted directly population nine scenarios. values differ shown example set RNG seed.","code":"# define a population model for each of the four populations in popdyn #   but without the add_remove_post or covariates components, #   which will be redefined below popmat_list <- lapply(popdyn, function(x) x$matrix) popdyn <- lapply(   popmat_list,   dynamics,   envstoch,   demostoch,   dd )   # define a dummy metapopulation structure with one #   \"dispersal\" link metapopstr <- matrix(0, nrow = 4, ncol = 4) metapopstr[1, 2] <- 1  # define a dummy dispersal link that has zero probability #   of any movements dispersal_matrix <- matrix(0, nrow = 5, ncol = 5) disp_tmp <- dispersal(dispersal_matrix)  # combine this into a metapopulation object metapopdyn <- metapopulation(metapopstr, popdyn, list(disp_tmp)) # wrapper function to define the removals function for each #   population (specified with idx) define_removals <- function(idx) {      function(n, remove) {          # add some stochasticity in the number of removals     remove <- rpois(1, lambda = remove[idx])        # check that there are enough individuals to remove,     #   only remove up to sum(n) individuals     if (remove > sum(n))       remove <- sum(n)          # work out which age classes to remove, sampled     #   randomly up to the total available in each     #   age class     n_available <- rep(3:5, times = n)     removal_idx <- sample.int(       length(n_available), size = remove, replace = FALSE     )          # expand this into a vector of removals by age class     remove <- table(n_available[removal_idx])     remove_expanded <- rep(0, 3)     names(remove_expanded) <- as.character(3:5)     remove_expanded[names(remove)] <- remove          # and return updated abundances     n - remove_expanded        }    }  # combine the masks for adults of each population with #   the removals function defined for populations 1-4 add_remove <- add_remove_post(   masks = list(     all_classes(metapopdyn$matrix, dims = 3:5),     all_classes(metapopdyn$matrix, dims = 8:10),     all_classes(metapopdyn$matrix, dims = 13:15),     all_classes(metapopdyn$matrix, dims = 18:20)),   funs = list(     define_removals(1),     define_removals(2),     define_removals(3),     define_removals(4)   ) )  # wrapper function to define the reproduction covariate effects #   for each population (specified with idx) define_reprod_effects <- function(idx) {    function(mat, x, alpha = 0.1, beta = 4, ...) {      # define a nonlinear effect of habitat     scale_factor <- 1 / (1 + alpha * exp(- beta * unlist(x)[idx]))          # return re-scaled survival values     mat * scale_factor        }    }  # wrapper function to define the survival covariate effects #   for each population (specified with idx) define_surv_effects <- function(idx) {    function(mat, x, alpha = 0.05, beta = 10, ...) {          # define a nonlinear effect of habitat     scale_factor <- 1 / (1 + alpha * exp(- beta * unlist(x)[idx]))          # return re-scaled survival values     mat * scale_factor        }    }  # helper function to define a reproduction mask for each #   population (specified with idx) define_reprod_mask <- function(mat, idx) {   idy <- 5 * (idx - 1)   row(mat) == (idy + 1) &     col(mat) %in% (3:5 + idy) }  # define masks for reproduction and transitions for each #   population covar_masks <- list(   define_reprod_mask(metapopdyn$matrix, 1),   define_reprod_mask(metapopdyn$matrix, 2),   define_reprod_mask(metapopdyn$matrix, 3),   define_reprod_mask(metapopdyn$matrix, 4),   transition(metapopdyn$matrix, dims = 1:5),   transition(metapopdyn$matrix, dims = 6:10),   transition(metapopdyn$matrix, dims = 11:15),   transition(metapopdyn$matrix, dims = 16:20) )  # combine reproduction and survival covariate effects into #   a list covar_funs <- list(   define_reprod_effects(1),   define_reprod_effects(2),   define_reprod_effects(3),   define_reprod_effects(4),   define_surv_effects(1),   define_surv_effects(2),   define_surv_effects(3),   define_surv_effects(4) )  # collate into a single covariates object covars <- covariates(   masks = covar_masks,   funs = covar_funs ) # update the metapopulation dynamics object metapopdyn <- update(metapopdyn, add_remove, covars)  # create a new initial abundance vector that has the same #   values as above but is a vector rather than matrix initial_abundance_meta <- c(initial_abundance)  # loop through each scenario quasi_ext_metapop <- matrix(NA, nrow = nrow(scenarios), ncol = npop) for (i in seq_len(nrow(scenarios))) {      # pull out the relevant actions   hab_tmp <- habitat[scenarios$habitat[i], ]   fish_tmp <- fishing[scenarios$fishing[i], ]      # define habitat extent taking into account restoration   extent_tmp <-restore(     n = hab_tmp[1],     amount = hab_tmp[2],     current = habitat_extent,     ntime = ntime   )      # only simulating a single metapopulation this time   sims <- simulate(     metapopdyn,     nsim = nsim,     init = initial_abundance_meta,     args = list(       covariates = format_covariates(extent_tmp),       add_remove_post = list(remove = fish_tmp)     )   )             # summarise the trajectories, with one step first to   #   subset the populations back into their own objects   sims_list <- lapply(     1:4,     function(i) subset(sims, subset = (5 * (i - 1) + 1):(5 * i))   )   quasi_ext_metapop[i, ] <- sapply(     sims_list,     calculate_quasi_extinction,     threshold = 10,     # the quasi-extinction level     subset = 3:5,       # focus on adults     include = TRUE      # less than or equal to threshold   )    } ##        habitat       fishing population 1 population 2 population 3 ## 1 restore_none regulate_none         0.96         0.96         0.92 ## 2  restore_one regulate_none         0.96         0.96         0.93 ## 3  restore_two regulate_none         0.96         0.96         0.93 ## 4 restore_none  regulate_two         0.00         0.00         0.93 ## 5  restore_one  regulate_two         0.00         0.00         0.93 ## 6  restore_two  regulate_two         0.00         0.00         0.92 ## 7 restore_none  regulate_all         0.08         0.07         0.04 ## 8  restore_one  regulate_all         0.07         0.06         0.06 ## 9  restore_two  regulate_all         0.06         0.06         0.05 ##   population 4 ## 1         0.94 ## 2         0.93 ## 3         0.94 ## 4         0.93 ## 5         0.94 ## 6         0.93 ## 7         0.06 ## 8         0.06 ## 9         0.05"},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jian Yen. Author, maintainer, copyright holder. Arthur Rylah Institute Environmental Research. Funder.","code":""},{"path":"https://aae-stats.github.io/aae.pop/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yen J (2026). aae.pop: Flexible Population Dynamics Simulations. R package version 0.2.0, https://aae-stats.github.io/aae.pop/.","code":"@Manual{,   title = {aae.pop: Flexible Population Dynamics Simulations},   author = {Jian Yen},   year = {2026},   note = {R package version 0.2.0},   url = {https://aae-stats.github.io/aae.pop/}, }"},{"path":"https://aae-stats.github.io/aae.pop/index.html","id":"aaepop-population-dynamics-models-in-r","dir":"","previous_headings":"","what":"aae.pop: population dynamics models in R","title":"Flexible Population Dynamics Simulations","text":"aae.pop plug--play tool simulate matrix population models. ’s designed fast, flexible, easily adapted different model structures, including complex demographic processes, metapopulations, multispecies models. website includes quick start guide, examples, vignettes, package documentation. Template models developed several species. included aae.pop.templates package described . can install current version package Github: aae.pop designed general package population models. Several existing models included aae.pop.templates package, can installed Github:","code":"remotes::install_github(\"aae-stats/aae.pop\") remotes::install_github(\"aae-stats/aae.pop.templates\")"},{"path":"https://aae-stats.github.io/aae.pop/reference/aae.pop.html","id":null,"dir":"Reference","previous_headings":"","what":"aae.pop: flexible simulation of multispecies population dynamics — aae.pop","title":"aae.pop: flexible simulation of multispecies population dynamics — aae.pop","text":"aae.pop supports flexible specification population   dynamics tools simulating single multispecies dynamics,   including metapopulation structures. See dynamics simulate detailed   examples model definition simulation.","code":""},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/reference/aae.pop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"aae.pop: flexible simulation of multispecies population dynamics — aae.pop","text":"Maintainer: Jian Yen jdl.yen@gmail.com [copyright holder] contributors: Arthur Rylah Institute Environmental Research [funder]","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/add_remove.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify additions or removals in models of population dynamics — add_remove","title":"Specify additions or removals in models of population dynamics — add_remove","text":"Specify additions removals population vector   occur (add_remove_pre) update step   (add_remove_post).","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/add_remove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify additions or removals in models of population dynamics — add_remove","text":"","code":"add_remove_pre(masks, funs)  add_remove_post(masks, funs)"},{"path":"https://aae-stats.github.io/aae.pop/reference/add_remove.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify additions or removals in models of population dynamics — add_remove","text":"masks logical matrix vector (list ) defining cells affected funs. See Details masks funs function list functions one element element masks. See Details","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/add_remove.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify additions or removals in models of population dynamics — add_remove","text":"add_remove_pre add_remove_post object specifying   additions/removals process use dynamics","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/add_remove.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify additions or removals in models of population dynamics — add_remove","text":"add_remove_pre specifies function   operates population vector prior population   update step. Examples might include fatalities (recorded   absolute numbers), removals, additions   population occur prior update (shifting   one generation next). add_remove_post add_remove_pre   operates population vector population   update step. masks logical vectors one element   class. Additional details masks provided   masks. funs takes one argument, population   abundances n prior (add_remove_pre)   following (add_remove_post) updates   given iteration/generation. allows direct additions   removals population vector, potentially based   external arguments (e.g., mass mortality events   harvesting). Additional arguments functions supported can   passed simulate args argument.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/add_remove.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify additions or removals in models of population dynamics — add_remove","text":"","code":"# define a population matrix (columns move to rows) nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # remove up to 10 individuals from stages 4 and 5 prior to the #   matrix update removals <- add_remove_pre(   masks = all_classes(popmat, dims = 4:5),   funs = \\(x) ifelse(x > 10, x - 10, 0) )  # update the dynamics object dyn <- update(dyn, removals)  # simulate trajectories sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))  # and plot plot(sims)   # remove up to 10 individuals from stages 4 and 5 after to the #   matrix update removals <- add_remove_post(   masks = all_classes(popmat, dims = 4:5),   funs = \\(x) ifelse(x > 10, x - 10, 0) )  # update the dynamics object (can't update because that will #   include the add_remove_pre as well) dyn <- dynamics(popmat, removals)  # simulate trajectories sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))  # and plot plot(sims)"},{"path":"https://aae-stats.github.io/aae.pop/reference/covariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify covariate dependence in models of population dynamics — covariates","title":"Specify covariate dependence in models of population dynamics — covariates","text":"Specify relationship vector matrix covariates   vital rates.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/covariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify covariate dependence in models of population dynamics — covariates","text":"","code":"covariates(masks, funs)  format_covariates(x, aux = NULL, names = NULL)"},{"path":"https://aae-stats.github.io/aae.pop/reference/covariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify covariate dependence in models of population dynamics — covariates","text":"masks logical matrix vector (list ) defining cells affected funs. See Details masks funs function list functions one element element masks. See Details x vector, matrix, data.frame time-varying covariate values one element row per time step aux additional, static arguments passed covariates function names optional vector names covariate included x","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/covariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify covariate dependence in models of population dynamics — covariates","text":"covariates object specifying covariate effects   matrix population model; use dynamics","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/covariates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify covariate dependence in models of population dynamics — covariates","text":"Masks must dimension population   dynamics matrix specify cells influenced covariates   according funs. Additional details masks   provided masks. Functions must take least one argument, vector matrix   representing masked elements population dynamics   matrix. Incorporating covariate values requires second   argument. Functions must return vector matrix   dimensions input, modified reflect   effects covariates vital rates. Additional arguments functions supported can   passed simulate args,   args.dyn, args.fn arguments. format_covariates helper function   takes covariates auxiliary values inputs   returns correctly formatted list can passed   args simulate.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/covariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify covariate dependence in models of population dynamics — covariates","text":"","code":"# define a population matrix (columns move to rows) nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # can add covariates that influence vital rates #   e.g., a logistic function covars <- covariates(   masks = transition(popmat),   funs = function(mat, x) mat * (1 / (1 + exp(-10 * x))) )  # simulate 50 random covariate values xvals <- matrix(runif(50), ncol = 1)  # update the dynamics object and simulate from it. #   Note that ntime is now captured in the 50 values #   of xvals, assuming we pass xvals as an argument #   to the covariates functions dyn <- update(dyn, covars) sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   args = list(     covariates = format_covariates(xvals)   ) )  # and can plot these simulated trajectories plot(sims)"},{"path":"https://aae-stats.github.io/aae.pop/reference/density_dependence.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify density dependence in models of population dynamics — density_dependence","title":"Specify density dependence in models of population dynamics — density_dependence","text":"Specify density dependence vital rates   (density_dependence) total abundances   (density_dependence_n).","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_dependence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify density dependence in models of population dynamics — density_dependence","text":"","code":"density_dependence(masks, funs, nmask = NULL)  density_dependence_n(masks, funs)"},{"path":"https://aae-stats.github.io/aae.pop/reference/density_dependence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify density dependence in models of population dynamics — density_dependence","text":"masks logical matrix vector (list ) defining cells affected funs. See Details masks funs function list functions one element element masks. See Details nmask logical vector list vectors defining elements population vector affected mask-function pair. Intended primarily internal use scaling processes metapopulation","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_dependence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify density dependence in models of population dynamics — density_dependence","text":"density_dependence object specifying covariate effects   matrix population model; use dynamics","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_dependence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify density dependence in models of population dynamics — density_dependence","text":"density_dependence specifies standard   density dependence vital rates, scramble   contest competition allee effects. density_dependence_n alternative   parameterisation density dependence acts directly   population abundances. Note density_dependence_n   superseded add_remove_post. Masks must dimension population   dynamics matrix specify cells influenced density   dependence according funs. case   density_dependence_n, masks   logical vectors one element class.   Additional details masks provided   masks. using density_depenence, functions must take   least two arguments, matrix x vector n,   represent population dynamics matrix   population abundances. Functions must return matrix   dimensions x, modified reflect   effects current abundances (n)   vital rates. case density_dependence_n,   funs takes one argument, population   abundances n following updates   given iteration/generation. allows rescaling   population abundances based total abundance   complicated functions depend   external arguments (e.g., mass mortality events   harvesting). Additional arguments functions supported can   passed simulate args,   args.dyn, args.fn arguments.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_dependence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify density dependence in models of population dynamics — density_dependence","text":"","code":"# define a population matrix (columns move to rows) nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # add some density dependence dd <- density_dependence(   masks = reproduction(popmat, dims = 4:5),   funs = ricker(1000) )  # update the dynamics object dyn <- update(dyn, dd)  # simulate trajectories sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))  # and plot plot(sims)"},{"path":"https://aae-stats.github.io/aae.pop/reference/density_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Common forms of density dependence — density_functions","title":"Common forms of density dependence — density_functions","text":"Use pre-defined forms density dependence   based common density-dependence functions.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Common forms of density dependence — density_functions","text":"","code":"beverton_holt(k, exclude = NULL)  ricker(k, exclude = NULL)"},{"path":"https://aae-stats.github.io/aae.pop/reference/density_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common forms of density dependence — density_functions","text":"k carrying capacity used define models density dependence. See details currently implemented models parameters. exclude vector classes exclude calculation total population density. Defaults NULL, case classes used","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Common forms of density dependence — density_functions","text":"functions can used density_dependence   specify common models density dependence","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Common forms of density dependence — density_functions","text":"Additional functions provided define common   forms density dependence. Currently implemented models   Ricker model Beverton-Holt model,   single parameter k.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/density_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Common forms of density dependence — density_functions","text":"","code":"# define a population matrix (columns move to rows) nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # add some density dependence dd <- density_dependence(   masks = reproduction(popmat, dims = 4:5),   funs = ricker(1000) )  # update the dynamics object dyn <- update(dyn, dd)  # simulate trajectories sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))  # and plot plot(sims)"},{"path":"https://aae-stats.github.io/aae.pop/reference/dispersal.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify dispersal between populations in a metapopulation model — dispersal","title":"Specify dispersal between populations in a metapopulation model — dispersal","text":"Specify dispersal populations, including stochasticity   density dependence dispersal parameters","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/dispersal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify dispersal between populations in a metapopulation model — dispersal","text":"","code":"dispersal(   kernel,   stochasticity_masks = NULL,   stochasticity_funs = NULL,   density_masks = NULL,   density_funs = NULL,   proportion = FALSE )"},{"path":"https://aae-stats.github.io/aae.pop/reference/dispersal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify dispersal between populations in a metapopulation model — dispersal","text":"kernel numeric matrix specifying probability specific classes moving two populations. Matrices columns-move--rows structure population dynamics matrices described dynamics, non-zero value cell (, b) denotes transition class b source population class receiving population stochasticity_masks logical matrix list logical matrices defining cells affected stochasticity_funs. See Details masks stochasticity_funs function list functions one element element stochasticity_masks. See Details density_masks logical matrix list logical matrices defining cells affected density_funs. See Details masks density_funs function list functions one element element density_masks. See Details proportion logical indicating whether kernel specified absolute probabilities proportion source population (defaults FALSE). TRUE, values kernel calculated proportion total probability individual exits class given time step","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/dispersal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify dispersal between populations in a metapopulation model — dispersal","text":"dispersal object specifying probabilities movement   populations metapopulation matrix model; use   metapopulation","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/dispersal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify dispersal between populations in a metapopulation model — dispersal","text":"","code":"# define some populations, all with identical vital rates nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- lapply(   1:3,   function(i) dynamics(popmat) )  # define metapopulation structure with populations #   1 and 3 dispersing into population 2 pop_structure <- matrix(0, nrow = 3, ncol = 3) pop_structure[1, 2] <- 1 pop_structure[3, 2] <- 1  # define dispersal between populations dispersal_matrix <- matrix(0, nrow = nclass, ncol = nclass) dispersal_matrix[survival(dispersal_matrix, dims = 20:25)] <- 0.2 pop_dispersal1 <- dispersal(dispersal_matrix, proportion = TRUE) pop_dispersal2 <- dispersal(dispersal_matrix, proportion = FALSE) pop_dispersal <- list(pop_dispersal1, pop_dispersal2)  # create metapopulation object metapop <- metapopulation(pop_structure, dyn, pop_dispersal)  # simulate without covariates sims <- simulate(metapop, nsim = 10)  # and plot the simulated trajectories plot(sims)"},{"path":"https://aae-stats.github.io/aae.pop/reference/dynamics.html","id":null,"dir":"Reference","previous_headings":"","what":"Create and update population dynamics objects — dynamics","title":"Create and update population dynamics objects — dynamics","text":"Define population dynamics matrix additional   objects determine covariate effects, density dependence,   forms stochasticity.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/dynamics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create and update population dynamics objects — dynamics","text":"","code":"dynamics(matrix, ...)  # S3 method for class 'dynamics' update(object, ...)  is.dynamics(x)"},{"path":"https://aae-stats.github.io/aae.pop/reference/dynamics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create and update population dynamics objects — dynamics","text":"matrix matrix vital rates specifying transitions ages stages. Specified format ntp1 =  matrix nt vector abundances, values given column row denote transition column row ... additional objects used define population dynamics. Must one covariates, replicated_covariates, environmental_stochasticity, demographic_stochasticity, density_dependence, add_remove_pre, add_remove_post. Note density_dependence_n equivalent add_remove_post. object dynamics object x object pass .dynamics","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/dynamics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create and update population dynamics objects — dynamics","text":"dynamics object containing matrix population model   associated processes","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/dynamics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create and update population dynamics objects — dynamics","text":"call dynamics defines object class   dynamics, can used simulate population   trajectories simulate function. plot   function supported generate general life-cycle   diagram based defined population dynamics. compiled dynamics object can   updated change included processes   update function.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/dynamics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create and update population dynamics objects — dynamics","text":"","code":"# define a population nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # and plot this if (rlang::is_installed(\"DiagrammeR\")) {   plot(dyn) }  {\"x\":{\"diagram\":\"digraph {\\n\\ngraph [layout = \\\"dot\\\",\\n       outputorder = \\\"edgesfirst\\\",\\n       bgcolor = \\\"white\\\",\\n       rankdir = \\\"LR\\\"]\\n\\nnode [fontname = \\\"Helvetica\\\",\\n      fontsize = \\\"10\\\",\\n      shape = \\\"circle\\\",\\n      fixedsize = \\\"true\\\",\\n      width = \\\"0.5\\\",\\n      style = \\\"filled\\\",\\n      fillcolor = \\\"aliceblue\\\",\\n      color = \\\"gray70\\\",\\n      fontcolor = \\\"gray50\\\"]\\n\\nedge [fontname = \\\"Helvetica\\\",\\n     fontsize = \\\"8\\\",\\n     len = \\\"1.5\\\",\\n     color = \\\"gray80\\\",\\n     arrowsize = \\\"0.5\\\"]\\n\\n  \\\"1\\\" [label = \\\"Age 1\\\", fontcolor = \\\"#4F7942\\\", fontsize = \\\"12\\\", penwidth = \\\"2\\\", shape = \\\"circle\\\", color = \\\"#4F7942\\\", fillcolor = \\\"#4F794250\\\", width = \\\"0.9\\\", height = \\\"0.72\\\"] \\n  \\\"2\\\" [label = \\\"Age 2\\\", fontcolor = \\\"#4F7942\\\", fontsize = \\\"12\\\", penwidth = \\\"2\\\", shape = \\\"circle\\\", color = \\\"#4F7942\\\", fillcolor = \\\"#4F794250\\\", width = \\\"0.9\\\", height = \\\"0.72\\\"] \\n  \\\"3\\\" [label = \\\"Age 3\\\", fontcolor = \\\"#4F7942\\\", fontsize = \\\"12\\\", penwidth = \\\"2\\\", shape = \\\"circle\\\", color = \\\"#4F7942\\\", fillcolor = \\\"#4F794250\\\", width = \\\"0.9\\\", height = \\\"0.72\\\"] \\n  \\\"4\\\" [label = \\\"Age 4\\\", fontcolor = \\\"#0E4D92\\\", fontsize = \\\"12\\\", penwidth = \\\"2\\\", shape = \\\"circle\\\", color = \\\"#0E4D92\\\", fillcolor = \\\"#0E4D9250\\\", width = \\\"0.9\\\", height = \\\"0.72\\\"] \\n  \\\"5\\\" [label = \\\"Age 5\\\", fontcolor = \\\"#0E4D92\\\", fontsize = \\\"12\\\", penwidth = \\\"2\\\", shape = \\\"circle\\\", color = \\\"#0E4D92\\\", fillcolor = \\\"#0E4D9250\\\", width = \\\"0.9\\\", height = \\\"0.72\\\"] \\n\\\"1\\\"->\\\"2\\\" [color = \\\"Gainsboro\\\", fontname = \\\"Avenir\\\", fontcolor = \\\"LightGray\\\", fontsize = \\\"14\\\", penwidth = \\\"4\\\", label = \\\"transition\\\", style = \\\"solid\\\"] \\n\\\"2\\\"->\\\"3\\\" [color = \\\"Gainsboro\\\", fontname = \\\"Avenir\\\", fontcolor = \\\"LightGray\\\", fontsize = \\\"14\\\", penwidth = \\\"4\\\", label = \\\"transition\\\", style = \\\"solid\\\"] \\n\\\"3\\\"->\\\"4\\\" [color = \\\"Gainsboro\\\", fontname = \\\"Avenir\\\", fontcolor = \\\"LightGray\\\", fontsize = \\\"14\\\", penwidth = \\\"4\\\", label = \\\"transition\\\", style = \\\"solid\\\"] \\n\\\"4\\\"->\\\"1\\\" [color = \\\"Gainsboro\\\", fontname = \\\"Avenir\\\", fontcolor = \\\"LightGray\\\", fontsize = \\\"14\\\", penwidth = \\\"4\\\", label = \\\"reproduction\\\", style = \\\"dashed\\\"] \\n\\\"4\\\"->\\\"5\\\" [color = \\\"Gainsboro\\\", fontname = \\\"Avenir\\\", fontcolor = \\\"LightGray\\\", fontsize = \\\"14\\\", penwidth = \\\"4\\\", label = \\\"transition\\\", style = \\\"solid\\\"] \\n\\\"5\\\"->\\\"1\\\" [color = \\\"Gainsboro\\\", fontname = \\\"Avenir\\\", fontcolor = \\\"LightGray\\\", fontsize = \\\"14\\\", penwidth = \\\"4\\\", label = \\\"reproduction\\\", style = \\\"dashed\\\"] \\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://aae-stats.github.io/aae.pop/reference/emps.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate expected minimum population size (EMPS) for a simulate object — emps","title":"Calculate expected minimum population size (EMPS) for a simulate object — emps","text":"Calculate expected minimum population size (EMPS)   simulate object","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/emps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate expected minimum population size (EMPS) for a simulate object — emps","text":"","code":"emps(sims, subset = NULL, times = NULL, fun = mean, ...)"},{"path":"https://aae-stats.github.io/aae.pop/reference/emps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate expected minimum population size (EMPS) for a simulate object — emps","text":"sims object returned simulate subset integer vector denoting population classes include calculation population abundance. Defaults classes times integer vector specifying generations include calculation extinction risk. Defaults simulated generations fun function used calculate average replicate trajectories. Defaults mean. Alternatives might include median min ... additional arguments passed fun","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/emps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate expected minimum population size (EMPS) for a simulate object — emps","text":"single value representing expected minimum population   size simulation","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/emps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate expected minimum population size (EMPS) for a simulate object — emps","text":"Expected minimum population size (EMPS) average   minimum value replicate trajectories. value represents   expected lower bound population sizes generations,   accounting variation among replicates. Abundances   can specified population classes subset   classes.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/emps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate expected minimum population size (EMPS) for a simulate object — emps","text":"","code":"# define a basic population nstage <- 5 popmat <- matrix(0, nrow = nstage, ncol = nstage) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # simulate with the default updater sims <- simulate(dyn, nsim = 1000)  # calculate expected minimum population size emps(sims) #> [1] 35.65322  # calculate expected minimum population size for 4 and 5 year #   olds only emps(sims, subset = 4:5) #> [1] 1.320385  # calculate expected minimum population size but ignore first 10 years emps(sims, times = 11:51) #> [1] 35.99845  # calculate expected minimum population size based on median emps(sims, fun = median) #> [1] 35.6637"},{"path":"https://aae-stats.github.io/aae.pop/reference/exps.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate expected population size for a simulate object based on generic functions (ExPS) — exps","title":"Calculate expected population size for a simulate object based on generic functions (ExPS) — exps","text":"Calculate expected population size   simulate object based   generic functions (ExPS)","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/exps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate expected population size for a simulate object based on generic functions (ExPS) — exps","text":"","code":"exps(   sims,   subset = NULL,   times = NULL,   fun_within = mean,   fun_among = mean,   ... )"},{"path":"https://aae-stats.github.io/aae.pop/reference/exps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate expected population size for a simulate object based on generic functions (ExPS) — exps","text":"sims object returned simulate subset integer vector denoting population classes include calculation population abundance. Defaults classes times integer vector specifying generations include calculation extinction risk. Defaults simulated generations fun_within function used summarise single trajectory. Must return single value. Defaults mean fun_among function used summarise replicate trajectories. Defaults mean. Alternatives might include median min ... additional arguments passed fun_within fun_among. conflict, wrapper function used define expected arguments function","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/exps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate expected population size for a simulate object based on generic functions (ExPS) — exps","text":"single value representing expected statistic applied   population sizes generated simulate","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/exps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate expected population size for a simulate object based on generic functions (ExPS) — exps","text":"Expected population size (ExPS) highly   flexible generalisation emps   represents two-level summary first summarises   individual population trajectories summarises   values replicates. Abundances   can specified population classes subset   classes.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/exps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate expected population size for a simulate object based on generic functions (ExPS) — exps","text":"","code":"# define a basic population nstage <- 5 popmat <- matrix(0, nrow = nstage, ncol = nstage) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # simulate with the default updater sims <- simulate(dyn, nsim = 1000)  # calculate expected population size exps(sims) #> [1] 96.072  # calculate expected population size for 4 and 5 year #   olds only exps(sims, subset = 4:5) #> [1] 4.860821  # calculate expected population size but ignore first 10 years exps(sims, times = 11:51) #> [1] 79.90515  # calculate expected population size based on median exps(sims, fun_among = median) #> [1] 95.3747  # calculate expected maximum population size based on median exps(sims, fun_within = max, fun_among = median) #> [1] 322.7  # calculate exps with conflicting quantile functions, handling #   conflicting arguments with wrapper functions quant1 <- function(x, p1, ...) {   quantile(x, prob = p1) } quant2 <- function(x, p2, ...) {   quantile(x, prob = p2) } exps(   sims,   fun_within = quant1, fun_among = quant2, p1 = 0.25, p2 = 0.75 ) #>     75%  #> 60.7253"},{"path":"https://aae-stats.github.io/aae.pop/reference/get_cdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the cumulative distribution function of a summary statistic across all iterations of a simulate object — get_cdf","title":"Calculate the cumulative distribution function of a summary statistic across all iterations of a simulate object — get_cdf","text":"Calculate cumulative distribution function   summary statistic across iterations   simulate object","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_cdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the cumulative distribution function of a summary statistic across all iterations of a simulate object — get_cdf","text":"","code":"get_cdf(sims, subset = NULL, times = NULL, n = 100, fn = min, ...)"},{"path":"https://aae-stats.github.io/aae.pop/reference/get_cdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the cumulative distribution function of a summary statistic across all iterations of a simulate object — get_cdf","text":"sims object returned simulate subset integer vector denoting population classes include calculation population abundance. Defaults classes times integer vector specifying generations include calculation extinction risk. Defaults simulated generations n integer specifying number threshold values use default case threshold specified. Defaults 100 fn function apply iteration. Defaults min ... additional arguments passed fn","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_cdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the cumulative distribution function of a summary statistic across all iterations of a simulate object — get_cdf","text":"data.frame containing prob column indicates   probability population fall threshold value   value column","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_cdf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the cumulative distribution function of a summary statistic across all iterations of a simulate object — get_cdf","text":"get_cdf faster   general alternative risk_curve function.   get_cdf can used calculate cumulative   distribution summary statistic. example,   cumulative distribution minimum population size   equivalent risk curve. Summary statistics   get_cdf extracted simulate   object represent cumulative distribution   statistic replicate trajectories time step   within set period. Abundances can specified   population classes subset classes.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_cdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the cumulative distribution function of a summary statistic across all iterations of a simulate object — get_cdf","text":"","code":"# define a basic population nstage <- 5 popmat <- matrix(0, nrow = nstage, ncol = nstage) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # simulate with the default updater sims <- simulate(dyn, nsim = 1000)  # calculate distribution of minimum population sizes (default) get_cdf(sims) #>     prob    value #> 1   0.00 16.30499 #> 2   0.01 22.43665 #> 3   0.02 23.47920 #> 4   0.03 24.58012 #> 5   0.04 25.17847 #> 6   0.05 25.89223 #> 7   0.06 26.18922 #> 8   0.07 26.58227 #> 9   0.08 27.06739 #> 10  0.09 27.40426 #> 11  0.10 27.76330 #> 12  0.11 28.11301 #> 13  0.12 28.48490 #> 14  0.13 28.73059 #> 15  0.14 28.92384 #> 16  0.15 29.28635 #> 17  0.16 29.55179 #> 18  0.17 29.79708 #> 19  0.18 29.98027 #> 20  0.19 30.10235 #> 21  0.20 30.31807 #> 22  0.21 30.50218 #> 23  0.22 30.73326 #> 24  0.23 31.02480 #> 25  0.24 31.38251 #> 26  0.25 31.50897 #> 27  0.26 31.67490 #> 28  0.27 31.84011 #> 29  0.28 32.02076 #> 30  0.29 32.11840 #> 31  0.30 32.27836 #> 32  0.31 32.41805 #> 33  0.32 32.61042 #> 34  0.33 32.88687 #> 35  0.34 33.05765 #> 36  0.35 33.25432 #> 37  0.36 33.39493 #> 38  0.37 33.71578 #> 39  0.38 33.89373 #> 40  0.39 34.00652 #> 41  0.40 34.10491 #> 42  0.41 34.29988 #> 43  0.42 34.46906 #> 44  0.43 34.62938 #> 45  0.44 34.79762 #> 46  0.45 34.96862 #> 47  0.46 35.03060 #> 48  0.47 35.11433 #> 49  0.48 35.26490 #> 50  0.49 35.44379 #> 51  0.50 35.61827 #> 52  0.51 35.71429 #> 53  0.52 35.81046 #> 54  0.53 35.98469 #> 55  0.54 36.00985 #> 56  0.55 36.16292 #> 57  0.56 36.36637 #> 58  0.57 36.52719 #> 59  0.58 36.69159 #> 60  0.59 36.92817 #> 61  0.60 37.00000 #> 62  0.61 37.10172 #> 63  0.62 37.26884 #> 64  0.63 37.36489 #> 65  0.64 37.47648 #> 66  0.65 37.60743 #> 67  0.66 37.90248 #> 68  0.67 38.04388 #> 69  0.68 38.17743 #> 70  0.69 38.26990 #> 71  0.70 38.52281 #> 72  0.71 38.77707 #> 73  0.72 39.00294 #> 74  0.73 39.19514 #> 75  0.74 39.49518 #> 76  0.75 39.61129 #> 77  0.76 39.86391 #> 78  0.77 40.00000 #> 79  0.78 40.22007 #> 80  0.79 40.52953 #> 81  0.80 40.75290 #> 82  0.81 40.98438 #> 83  0.82 41.06025 #> 84  0.83 41.34185 #> 85  0.84 41.57229 #> 86  0.85 41.99953 #> 87  0.86 42.15422 #> 88  0.87 42.33000 #> 89  0.88 42.65776 #> 90  0.89 42.95536 #> 91  0.90 43.10349 #> 92  0.91 43.51349 #> 93  0.92 44.00000 #> 94  0.93 44.33328 #> 95  0.94 44.91363 #> 96  0.95 45.15529 #> 97  0.96 45.74946 #> 98  0.97 46.39202 #> 99  0.98 47.14190 #> 100 0.99 49.00000 #> 101 1.00 55.00000  # calculate distribution of maximum population sizes get_cdf(sims, fn = max) #>     prob    value #> 1   0.00 106.6000 #> 2   0.01 179.2690 #> 3   0.02 188.6445 #> 4   0.03 194.3835 #> 5   0.04 205.2020 #> 6   0.05 214.3662 #> 7   0.06 219.1335 #> 8   0.07 223.7510 #> 9   0.08 225.7800 #> 10  0.09 230.1690 #> 11  0.10 232.6200 #> 12  0.11 235.0225 #> 13  0.12 237.5710 #> 14  0.13 242.7435 #> 15  0.14 245.5720 #> 16  0.15 247.5475 #> 17  0.16 251.6210 #> 18  0.17 254.2320 #> 19  0.18 256.2115 #> 20  0.19 257.0810 #> 21  0.20 260.9200 #> 22  0.21 263.7765 #> 23  0.22 264.7500 #> 24  0.23 266.2425 #> 25  0.24 267.7880 #> 26  0.25 271.8062 #> 27  0.26 273.7110 #> 28  0.27 274.9365 #> 29  0.28 276.2860 #> 30  0.29 277.0000 #> 31  0.30 278.1850 #> 32  0.31 279.5225 #> 33  0.32 282.6180 #> 34  0.33 284.4500 #> 35  0.34 286.0480 #> 36  0.35 287.1825 #> 37  0.36 288.1300 #> 38  0.37 291.4667 #> 39  0.38 293.5170 #> 40  0.39 295.0500 #> 41  0.40 297.1800 #> 42  0.41 297.8500 #> 43  0.42 300.2190 #> 44  0.43 303.0855 #> 45  0.44 305.7080 #> 46  0.45 306.9638 #> 47  0.46 308.1850 #> 48  0.47 309.5445 #> 49  0.48 313.2550 #> 50  0.49 315.1520 #> 51  0.50 316.9500 #> 52  0.51 317.3000 #> 53  0.52 318.3940 #> 54  0.53 320.3735 #> 55  0.54 323.4230 #> 56  0.55 324.5225 #> 57  0.56 325.9420 #> 58  0.57 327.8865 #> 59  0.58 329.1210 #> 60  0.59 331.5615 #> 61  0.60 334.7000 #> 62  0.61 336.1890 #> 63  0.62 337.1950 #> 64  0.63 338.4665 #> 65  0.64 342.3480 #> 66  0.65 344.2050 #> 67  0.66 345.8190 #> 68  0.67 347.6495 #> 69  0.68 348.4160 #> 70  0.69 351.4440 #> 71  0.70 355.5600 #> 72  0.71 356.5500 #> 73  0.72 357.8640 #> 74  0.73 359.7715 #> 75  0.74 362.1320 #> 76  0.75 364.7125 #> 77  0.76 367.2120 #> 78  0.77 368.9402 #> 79  0.78 373.2110 #> 80  0.79 376.0210 #> 81  0.80 377.4300 #> 82  0.81 380.1570 #> 83  0.82 385.8770 #> 84  0.83 388.2670 #> 85  0.84 392.7460 #> 86  0.85 397.0300 #> 87  0.86 400.5060 #> 88  0.87 405.8130 #> 89  0.88 408.3100 #> 90  0.89 410.0555 #> 91  0.90 415.3600 #> 92  0.91 420.7360 #> 93  0.92 427.6780 #> 94  0.93 429.9990 #> 95  0.94 436.1120 #> 96  0.95 440.1075 #> 97  0.96 447.9680 #> 98  0.97 457.8770 #> 99  0.98 473.6580 #> 100 0.99 496.6065 #> 101 1.00 626.6000  # calculate distribution of the 90th percentile of #   population sizes get_cdf(sims, fn = quantile, prob = 0.9) #>     prob     value #> 1   0.00  72.60405 #> 2   0.01 103.12801 #> 3   0.02 108.89865 #> 4   0.03 114.06997 #> 5   0.04 117.19870 #> 6   0.05 119.33873 #> 7   0.06 120.56043 #> 8   0.07 122.34790 #> 9   0.08 125.22585 #> 10  0.09 126.53797 #> 11  0.10 127.91653 #> 12  0.11 129.69148 #> 13  0.12 130.97569 #> 14  0.13 133.46854 #> 15  0.14 134.16345 #> 16  0.15 136.12869 #> 17  0.16 136.85054 #> 18  0.17 137.94612 #> 19  0.18 139.17403 #> 20  0.19 140.66085 #> 21  0.20 141.84262 #> 22  0.21 142.48935 #> 23  0.22 143.45515 #> 24  0.23 144.25643 #> 25  0.24 145.18974 #> 26  0.25 145.95662 #> 27  0.26 146.72567 #> 28  0.27 147.79791 #> 29  0.28 148.70207 #> 30  0.29 150.35767 #> 31  0.30 151.22616 #> 32  0.31 152.00739 #> 33  0.32 152.53833 #> 34  0.33 153.35770 #> 35  0.34 154.16472 #> 36  0.35 154.94460 #> 37  0.36 155.63246 #> 38  0.37 156.42225 #> 39  0.38 157.49263 #> 40  0.39 158.08255 #> 41  0.40 158.99100 #> 42  0.41 159.95092 #> 43  0.42 160.60352 #> 44  0.43 161.55798 #> 45  0.44 162.32917 #> 46  0.45 163.04694 #> 47  0.46 163.57178 #> 48  0.47 164.15111 #> 49  0.48 164.52461 #> 50  0.49 165.12837 #> 51  0.50 166.22906 #> 52  0.51 167.11401 #> 53  0.52 167.95114 #> 54  0.53 168.98904 #> 55  0.54 169.39988 #> 56  0.55 170.16796 #> 57  0.56 171.06326 #> 58  0.57 171.77349 #> 59  0.58 172.83457 #> 60  0.59 173.32716 #> 61  0.60 174.18867 #> 62  0.61 174.90557 #> 63  0.62 176.03002 #> 64  0.63 176.61001 #> 65  0.64 177.52854 #> 66  0.65 178.56211 #> 67  0.66 179.10518 #> 68  0.67 179.66187 #> 69  0.68 180.24424 #> 70  0.69 180.86417 #> 71  0.70 181.76897 #> 72  0.71 182.59767 #> 73  0.72 183.57485 #> 74  0.73 184.46605 #> 75  0.74 185.06136 #> 76  0.75 186.48697 #> 77  0.76 187.14173 #> 78  0.77 188.71216 #> 79  0.78 190.27955 #> 80  0.79 190.91235 #> 81  0.80 191.56821 #> 82  0.81 192.60072 #> 83  0.82 194.23600 #> 84  0.83 195.03251 #> 85  0.84 196.88636 #> 86  0.85 197.68352 #> 87  0.86 198.68146 #> 88  0.87 201.58530 #> 89  0.88 202.68951 #> 90  0.89 204.98666 #> 91  0.90 206.59388 #> 92  0.91 208.95055 #> 93  0.92 211.37520 #> 94  0.93 213.38728 #> 95  0.94 215.90461 #> 96  0.95 217.58186 #> 97  0.96 219.72101 #> 98  0.97 223.29559 #> 99  0.98 230.97773 #> 100 0.99 238.22869 #> 101 1.00 316.65094  # calculate distribution of minimum population sizes #   but ignore first 10 years get_cdf(sims, fn = max, times = 11:51) #>     prob     value #> 1   0.00  72.60405 #> 2   0.01 115.76272 #> 3   0.02 121.43059 #> 4   0.03 125.23788 #> 5   0.04 128.73525 #> 6   0.05 130.90704 #> 7   0.06 133.18926 #> 8   0.07 135.54819 #> 9   0.08 137.51902 #> 10  0.09 140.88699 #> 11  0.10 142.47271 #> 12  0.11 146.08277 #> 13  0.12 147.81183 #> 14  0.13 149.24120 #> 15  0.14 150.92684 #> 16  0.15 152.40870 #> 17  0.16 153.88629 #> 18  0.17 155.69653 #> 19  0.18 157.21321 #> 20  0.19 158.74907 #> 21  0.20 160.13876 #> 22  0.21 161.44972 #> 23  0.22 162.65037 #> 24  0.23 163.45212 #> 25  0.24 164.26924 #> 26  0.25 165.49903 #> 27  0.26 166.61370 #> 28  0.27 167.57855 #> 29  0.28 168.85796 #> 30  0.29 170.21830 #> 31  0.30 171.24666 #> 32  0.31 172.84614 #> 33  0.32 174.01211 #> 34  0.33 174.82302 #> 35  0.34 175.66674 #> 36  0.35 176.22651 #> 37  0.36 177.13126 #> 38  0.37 177.85432 #> 39  0.38 178.58576 #> 40  0.39 179.13544 #> 41  0.40 179.92571 #> 42  0.41 180.90098 #> 43  0.42 182.23880 #> 44  0.43 183.27342 #> 45  0.44 184.08123 #> 46  0.45 184.81824 #> 47  0.46 185.37212 #> 48  0.47 186.16840 #> 49  0.48 187.27806 #> 50  0.49 188.56554 #> 51  0.50 189.59474 #> 52  0.51 190.27609 #> 53  0.52 191.02280 #> 54  0.53 191.94946 #> 55  0.54 193.00215 #> 56  0.55 194.51393 #> 57  0.56 195.38511 #> 58  0.57 196.15353 #> 59  0.58 196.96250 #> 60  0.59 198.55732 #> 61  0.60 199.46796 #> 62  0.61 200.67572 #> 63  0.62 201.26963 #> 64  0.63 202.01988 #> 65  0.64 202.78276 #> 66  0.65 203.86671 #> 67  0.66 205.05017 #> 68  0.67 205.91927 #> 69  0.68 206.36119 #> 70  0.69 207.15708 #> 71  0.70 208.05542 #> 72  0.71 209.70641 #> 73  0.72 210.93852 #> 74  0.73 212.33498 #> 75  0.74 213.53085 #> 76  0.75 214.96170 #> 77  0.76 216.47110 #> 78  0.77 217.56840 #> 79  0.78 218.99511 #> 80  0.79 220.03851 #> 81  0.80 221.47350 #> 82  0.81 222.80570 #> 83  0.82 224.39408 #> 84  0.83 225.89362 #> 85  0.84 228.06640 #> 86  0.85 230.53583 #> 87  0.86 231.99711 #> 88  0.87 233.67544 #> 89  0.88 235.96152 #> 90  0.89 237.32509 #> 91  0.90 239.50586 #> 92  0.91 241.64867 #> 93  0.92 243.63605 #> 94  0.93 246.81354 #> 95  0.94 247.76114 #> 96  0.95 251.45786 #> 97  0.96 254.22533 #> 98  0.97 257.74538 #> 99  0.98 268.63742 #> 100 0.99 279.46384 #> 101 1.00 370.99709"},{"path":"https://aae-stats.github.io/aae.pop/reference/get_pdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the probability density of a summary statistic across all iterations of a simulate object — get_pdf","title":"Calculate the probability density of a summary statistic across all iterations of a simulate object — get_pdf","text":"Calculate probability density summary   statistic across iterations   simulate object","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_pdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the probability density of a summary statistic across all iterations of a simulate object — get_pdf","text":"","code":"get_pdf(sims, subset = NULL, times = NULL, n = 100, fn = min, ...)"},{"path":"https://aae-stats.github.io/aae.pop/reference/get_pdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the probability density of a summary statistic across all iterations of a simulate object — get_pdf","text":"sims object returned simulate subset integer vector denoting population classes include calculation population abundance. Defaults classes times integer vector specifying generations include calculation extinction risk. Defaults simulated generations n integer specifying number threshold values use default case threshold specified. Defaults 100 fn function apply iteration. Defaults min ... additional arguments passed fn","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_pdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the probability density of a summary statistic across all iterations of a simulate object — get_pdf","text":"data.frame containing prob column indicates   probability density abundances vicinity   threshold value value column","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_pdf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the probability density of a summary statistic across all iterations of a simulate object — get_pdf","text":"get_pdf get_cdf faster   general alternatives risk_curve function.   get_pdf can used calculate probability   distribution summary statistic. example,   probability distribution minimum population size   density-based equivalent risk curve (function   get_cdf can used get true equivalent).   Summary statistics get_pdf extracted   simulate object represent distribution   statistic replicate trajectories time step   within set period. Abundances can specified   population classes subset classes.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/get_pdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the probability density of a summary statistic across all iterations of a simulate object — get_pdf","text":"","code":"# define a basic population nstage <- 5 popmat <- matrix(0, nrow = nstage, ncol = nstage) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # simulate with the default updater sims <- simulate(dyn, nsim = 1000)  # calculate distribution of minimum population sizes (default) get_pdf(sims) #>             prob    value #> 1   3.240007e-06 12.69176 #> 2   8.955087e-06 13.18776 #> 3   2.182391e-05 13.68376 #> 4   4.688103e-05 14.17976 #> 5   8.922445e-05 14.67576 #> 6   1.515009e-04 15.17176 #> 7   2.320442e-04 15.66775 #> 8   3.251992e-04 16.16375 #> 9   4.267327e-04 16.65975 #> 10  5.393383e-04 17.15575 #> 11  6.758139e-04 17.65175 #> 12  8.591638e-04 18.14775 #> 13  1.120100e-03 18.64375 #> 14  1.495614e-03 19.13975 #> 15  2.020424e-03 19.63575 #> 16  2.711010e-03 20.13175 #> 17  3.546512e-03 20.62775 #> 18  4.475699e-03 21.12375 #> 19  5.452390e-03 21.61975 #> 20  6.477319e-03 22.11575 #> 21  7.617109e-03 22.61175 #> 22  8.969425e-03 23.10774 #> 23  1.060198e-02 23.60374 #> 24  1.250380e-02 24.09974 #> 25  1.458417e-02 24.59574 #> 26  1.671881e-02 25.09174 #> 27  1.881810e-02 25.58774 #> 28  2.087408e-02 26.08374 #> 29  2.296599e-02 26.57974 #> 30  2.523640e-02 27.07574 #> 31  2.784019e-02 27.57174 #> 32  3.088030e-02 28.06774 #> 33  3.435840e-02 28.56374 #> 34  3.814941e-02 29.05974 #> 35  4.201835e-02 29.55574 #> 36  4.567569e-02 30.05174 #> 37  4.885831e-02 30.54774 #> 38  5.139728e-02 31.04373 #> 39  5.327011e-02 31.53973 #> 40  5.461029e-02 32.03573 #> 41  5.565148e-02 32.53173 #> 42  5.659113e-02 33.02773 #> 43  5.749847e-02 33.52373 #> 44  5.830843e-02 34.01973 #> 45  5.892166e-02 34.51573 #> 46  5.933133e-02 35.01173 #> 47  5.965453e-02 35.50773 #> 48  6.004045e-02 36.00373 #> 49  6.051938e-02 36.49973 #> 50  6.091524e-02 36.99573 #> 51  6.092167e-02 37.49173 #> 52  6.027214e-02 37.98773 #> 53  5.887756e-02 38.48372 #> 54  5.683454e-02 38.97972 #> 55  5.432993e-02 39.47572 #> 56  5.150186e-02 39.97172 #> 57  4.841460e-02 40.46772 #> 58  4.510608e-02 40.96372 #> 59  4.165218e-02 41.45972 #> 60  3.817701e-02 41.95572 #> 61  3.481629e-02 42.45172 #> 62  3.168166e-02 42.94772 #> 63  2.884928e-02 43.44372 #> 64  2.634665e-02 43.93972 #> 65  2.414469e-02 44.43572 #> 66  2.214140e-02 44.93172 #> 67  2.017454e-02 45.42772 #> 68  1.808189e-02 45.92371 #> 69  1.579466e-02 46.41971 #> 70  1.338249e-02 46.91571 #> 71  1.102408e-02 47.41171 #> 72  8.917680e-03 47.90771 #> 73  7.183771e-03 48.40371 #> 74  5.823279e-03 48.89971 #> 75  4.759141e-03 49.39571 #> 76  3.899598e-03 49.89171 #> 77  3.186176e-03 50.38771 #> 78  2.596237e-03 50.88371 #> 79  2.122389e-03 51.37971 #> 80  1.748987e-03 51.87571 #> 81  1.447631e-03 52.37171 #> 82  1.189415e-03 52.86771 #> 83  9.591326e-04 53.36371 #> 84  7.612502e-04 53.85970 #> 85  6.110312e-04 54.35570 #> 86  5.206261e-04 54.85170 #> 87  4.874162e-04 55.34770 #> 88  4.922827e-04 55.84370 #> 89  5.081908e-04 56.33970 #> 90  5.099932e-04 56.83570 #> 91  4.818448e-04 57.33170 #> 92  4.211933e-04 57.82770 #> 93  3.368892e-04 58.32370 #> 94  2.443657e-04 58.81970 #> 95  1.594872e-04 59.31570 #> 96  9.323814e-05 59.81170 #> 97  4.854606e-05 60.30770 #> 98  2.240754e-05 60.80370 #> 99  9.129717e-06 61.29969 #> 100 3.285163e-06 61.79569  # calculate distribution of maximum population sizes get_pdf(sims, fn = max) #>             prob     value #> 1   2.699979e-07  65.43841 #> 2   7.839197e-07  71.71364 #> 3   1.971247e-06  77.98888 #> 4   4.302163e-06  84.26411 #> 5   8.197538e-06  90.53935 #> 6   1.378040e-05  96.81458 #> 7   2.073962e-05 103.08981 #> 8   2.889461e-05 109.36505 #> 9   3.924172e-05 115.64028 #> 10  5.497950e-05 121.91552 #> 11  8.097212e-05 128.19075 #> 12  1.218735e-04 134.46599 #> 13  1.796936e-04 140.74122 #> 14  2.529659e-04 147.01645 #> 15  3.378829e-04 153.29169 #> 16  4.326025e-04 159.56692 #> 17  5.398222e-04 165.84216 #> 18  6.670719e-04 172.11739 #> 19  8.228009e-04 178.39262 #> 20  1.012825e-03 184.66786 #> 21  1.236700e-03 190.94309 #> 22  1.486299e-03 197.21833 #> 23  1.747115e-03 203.49356 #> 24  2.005618e-03 209.76880 #> 25  2.256268e-03 216.04403 #> 26  2.505703e-03 222.31926 #> 27  2.769545e-03 228.59450 #> 28  3.062505e-03 234.86973 #> 29  3.387507e-03 241.14497 #> 30  3.728788e-03 247.42020 #> 31  4.055776e-03 253.69543 #> 32  4.339112e-03 259.97067 #> 33  4.566934e-03 266.24590 #> 34  4.750975e-03 272.52114 #> 35  4.915911e-03 278.79637 #> 36  5.079076e-03 285.07160 #> 37  5.240339e-03 291.34684 #> 38  5.384323e-03 297.62207 #> 39  5.490440e-03 303.89731 #> 40  5.540192e-03 310.17254 #> 41  5.521206e-03 316.44778 #> 42  5.431466e-03 322.72301 #> 43  5.281453e-03 328.99824 #> 44  5.087611e-03 335.27348 #> 45  4.864220e-03 341.54871 #> 46  4.618451e-03 347.82395 #> 47  4.353472e-03 354.09918 #> 48  4.075789e-03 360.37441 #> 49  3.799520e-03 366.64965 #> 50  3.542727e-03 372.92488 #> 51  3.318189e-03 379.20012 #> 52  3.127410e-03 385.47535 #> 53  2.960311e-03 391.75059 #> 54  2.799390e-03 398.02582 #> 55  2.626678e-03 404.30105 #> 56  2.429267e-03 410.57629 #> 57  2.203573e-03 416.85152 #> 58  1.958904e-03 423.12676 #> 59  1.715081e-03 429.40199 #> 60  1.494382e-03 435.67722 #> 61  1.311757e-03 441.95246 #> 62  1.166996e-03 448.22769 #> 63  1.046983e-03 454.50293 #> 64  9.350639e-04 460.77816 #> 65  8.205497e-04 467.05340 #> 66  7.033717e-04 473.32863 #> 67  5.909143e-04 479.60386 #> 68  4.912177e-04 485.87910 #> 69  4.084969e-04 492.15433 #> 70  3.425066e-04 498.42957 #> 71  2.917394e-04 504.70480 #> 72  2.552392e-04 510.98003 #> 73  2.316231e-04 517.25527 #> 74  2.165441e-04 523.53050 #> 75  2.031799e-04 529.80574 #> 76  1.852065e-04 536.08097 #> 77  1.601722e-04 542.35620 #> 78  1.305830e-04 548.63144 #> 79  1.010865e-04 554.90667 #> 80  7.530188e-05 561.18191 #> 81  5.449032e-05 567.45714 #> 82  3.806736e-05 573.73238 #> 83  2.522270e-05 580.00761 #> 84  1.559197e-05 586.28284 #> 85  9.186977e-06 592.55808 #> 86  5.930222e-06 598.83331 #> 87  5.651103e-06 605.10855 #> 88  8.032273e-06 611.38378 #> 89  1.246782e-05 617.65901 #> 90  1.773680e-05 623.93425 #> 91  2.214265e-05 630.20948 #> 92  2.403433e-05 636.48472 #> 93  2.259774e-05 642.75995 #> 94  1.843248e-05 649.03519 #> 95  1.303669e-05 655.31042 #> 96  7.987373e-06 661.58565 #> 97  4.249244e-06 667.86089 #> 98  1.959609e-06 674.13612 #> 99  7.816987e-07 680.41136 #> 100 2.696301e-07 686.68659  # calculate distribution of the 90th percentile of #   population sizes get_pdf(sims, fn = quantile, prob = 0.9) #>             prob     value #> 1   6.364840e-07  51.99927 #> 2   1.798338e-06  54.59612 #> 3   4.444537e-06  57.19297 #> 4   9.586587e-06  59.78982 #> 5   1.811601e-05  62.38668 #> 6   3.014698e-05  64.98353 #> 7   4.447657e-05  67.58038 #> 8   5.895059e-05  70.17723 #> 9   7.204251e-05  72.77408 #> 10  8.468136e-05  75.37093 #> 11  1.013703e-04  77.96778 #> 12  1.293861e-04  80.56463 #> 13  1.769570e-04  83.16148 #> 14  2.511254e-04  85.75834 #> 15  3.561991e-04  88.35519 #> 16  4.918968e-04  90.95204 #> 17  6.550043e-04  93.54889 #> 18  8.426681e-04  96.14574 #> 19  1.056496e-03  98.74259 #> 20  1.303852e-03 101.33944 #> 21  1.593829e-03 103.93629 #> 22  1.929902e-03 106.53314 #> 23  2.303999e-03 109.12999 #> 24  2.699239e-03 111.72685 #> 25  3.103094e-03 114.32370 #> 26  3.522460e-03 116.92055 #> 27  3.986423e-03 119.51740 #> 28  4.534427e-03 122.11425 #> 29  5.189236e-03 124.71110 #> 30  5.942061e-03 127.30795 #> 31  6.752571e-03 129.90480 #> 32  7.567178e-03 132.50165 #> 33  8.343757e-03 135.09851 #> 34  9.063535e-03 137.69536 #> 35  9.718893e-03 140.29221 #> 36  1.029288e-02 142.88906 #> 37  1.075546e-02 145.48591 #> 38  1.108775e-02 148.08276 #> 39  1.131038e-02 150.67961 #> 40  1.148995e-02 153.27646 #> 41  1.170745e-02 155.87331 #> 42  1.200276e-02 158.47016 #> 43  1.234298e-02 161.06702 #> 44  1.263517e-02 163.66387 #> 45  1.277406e-02 166.26072 #> 46  1.270567e-02 168.85757 #> 47  1.244820e-02 171.45442 #> 48  1.207188e-02 174.05127 #> 49  1.165280e-02 176.64812 #> 50  1.123163e-02 179.24497 #> 51  1.080022e-02 181.84182 #> 52  1.032131e-02 184.43868 #> 53  9.761378e-03 187.03553 #> 54  9.119485e-03 189.63238 #> 55  8.435472e-03 192.22923 #> 56  7.770837e-03 194.82608 #> 57  7.180020e-03 197.42293 #> 58  6.685672e-03 200.01978 #> 59  6.267885e-03 202.61663 #> 60  5.881955e-03 205.21348 #> 61  5.480961e-03 207.81033 #> 62  5.034167e-03 210.40719 #> 63  4.535293e-03 213.00404 #> 64  3.996963e-03 215.60089 #> 65  3.443851e-03 218.19774 #> 66  2.908285e-03 220.79459 #> 67  2.425030e-03 223.39144 #> 68  2.022412e-03 225.98829 #> 69  1.714291e-03 228.58514 #> 70  1.495920e-03 231.18199 #> 71  1.346933e-03 233.77884 #> 72  1.240207e-03 236.37570 #> 73  1.152320e-03 238.97255 #> 74  1.066418e-03 241.56940 #> 75  9.722410e-04 244.16625 #> 76  8.664738e-04 246.76310 #> 77  7.523578e-04 249.35995 #> 78  6.379623e-04 251.95680 #> 79  5.325600e-04 254.55365 #> 80  4.426137e-04 257.15050 #> 81  3.703854e-04 259.74736 #> 82  3.145925e-04 262.34421 #> 83  2.715722e-04 264.94106 #> 84  2.363867e-04 267.53791 #> 85  2.046344e-04 270.13476 #> 86  1.740851e-04 272.73161 #> 87  1.451818e-04 275.32846 #> 88  1.201927e-04 277.92531 #> 89  1.011247e-04 280.52216 #> 90  8.802978e-05 283.11901 #> 91  7.856866e-05 285.71587 #> 92  6.926795e-05 288.31272 #> 93  5.772550e-05 290.90957 #> 94  4.396555e-05 293.50642 #> 95  2.995201e-05 296.10327 #> 96  1.804901e-05 298.70012 #> 97  9.566197e-06 301.29697 #> 98  4.439118e-06 303.89382 #> 99  1.797090e-06 306.49067 #> 100 6.362330e-07 309.08753  # calculate distribution of minimum population sizes #   but ignore first 10 years get_pdf(sims, fn = max, times = 11:51) #>             prob     value #> 1   5.139556e-07  50.45373 #> 2   1.382402e-06  53.50099 #> 3   3.301176e-06  56.54826 #> 4   6.980480e-06  59.59552 #> 5   1.311964e-05  62.64278 #> 6   2.203316e-05  65.69005 #> 7   3.334875e-05  68.73731 #> 8   4.611694e-05  71.78458 #> 9   5.957102e-05  74.83184 #> 10  7.414723e-05  77.87911 #> 11  9.194610e-05  80.92637 #> 12  1.163763e-04  83.97363 #> 13  1.515585e-04  87.02090 #> 14  2.019736e-04  90.06816 #> 15  2.734383e-04  93.11543 #> 16  3.732287e-04  96.16269 #> 17  5.081046e-04  99.20996 #> 18  6.805240e-04 102.25722 #> 19  8.835783e-04 105.30449 #> 20  1.103090e-03 108.35175 #> 21  1.323799e-03 111.39901 #> 22  1.538675e-03 114.44628 #> 23  1.754957e-03 117.49354 #> 24  1.991876e-03 120.54081 #> 25  2.270473e-03 123.58807 #> 26  2.602631e-03 126.63534 #> 27  2.985222e-03 129.68260 #> 28  3.402942e-03 132.72987 #> 29  3.837538e-03 135.77713 #> 30  4.279789e-03 138.82439 #> 31  4.734332e-03 141.87166 #> 32  5.215303e-03 144.91892 #> 33  5.735664e-03 147.96619 #> 34  6.295233e-03 151.01345 #> 35  6.875486e-03 154.06072 #> 36  7.443821e-03 157.10798 #> 37  7.964586e-03 160.15525 #> 38  8.412553e-03 163.20251 #> 39  8.782587e-03 166.24977 #> 40  9.088886e-03 169.29704 #> 41  9.352709e-03 172.34430 #> 42  9.590519e-03 175.39157 #> 43  9.806364e-03 178.43883 #> 44  9.990320e-03 181.48610 #> 45  1.012254e-02 184.53336 #> 46  1.018009e-02 187.58062 #> 47  1.014827e-02 190.62789 #> 48  1.003171e-02 193.67515 #> 49  9.856622e-03 196.72242 #> 50  9.658922e-03 199.76968 #> 51  9.459745e-03 202.81695 #> 52  9.251971e-03 205.86421 #> 53  9.005821e-03 208.91148 #> 54  8.689387e-03 211.95874 #> 55  8.291439e-03 215.00600 #> 56  7.823827e-03 218.05327 #> 57  7.311720e-03 221.10053 #> 58  6.781848e-03 224.14780 #> 59  6.258094e-03 227.19506 #> 60  5.762475e-03 230.24233 #> 61  5.314150e-03 233.28959 #> 62  4.922771e-03 236.33686 #> 63  4.579813e-03 239.38412 #> 64  4.257257e-03 242.43138 #> 65  3.918487e-03 245.47865 #> 66  3.537936e-03 248.52591 #> 67  3.114081e-03 251.57318 #> 68  2.669881e-03 254.62044 #> 69  2.242562e-03 257.66771 #> 70  1.869534e-03 260.71497 #> 71  1.575669e-03 263.76223 #> 72  1.367569e-03 266.80950 #> 73  1.232235e-03 269.85676 #> 74  1.142213e-03 272.90403 #> 75  1.065683e-03 275.95129 #> 76  9.786384e-04 278.99856 #> 77  8.719105e-04 282.04582 #> 78  7.502911e-04 285.09309 #> 79  6.266341e-04 288.14035 #> 80  5.148141e-04 291.18761 #> 81  4.240159e-04 294.23488 #> 82  3.571868e-04 297.28214 #> 83  3.118545e-04 300.32941 #> 84  2.822974e-04 303.37667 #> 85  2.619667e-04 306.42394 #> 86  2.450356e-04 309.47120 #> 87  2.275306e-04 312.51847 #> 88  2.071842e-04 315.56573 #> 89  1.831842e-04 318.61299 #> 90  1.558834e-04 321.66026 #> 91  1.266232e-04 324.70752 #> 92  9.731309e-05 327.75479 #> 93  7.007494e-05 330.80205 #> 94  4.680036e-05 333.84932 #> 95  2.873689e-05 336.89658 #> 96  1.608749e-05 339.94384 #> 97  8.145854e-06 342.99111 #> 98  3.706530e-06 346.03837 #> 99  1.507045e-06 349.08564 #> 100 5.480926e-07 352.13290"},{"path":"https://aae-stats.github.io/aae.pop/reference/masks.html","id":null,"dir":"Reference","previous_headings":"","what":"Isolate elements of population dynamics models — masks","title":"Isolate elements of population dynamics models — masks","text":"Helper functions isolate particular components   population dynamics model, reproduction terms,   transition/growth terms, particular life stages   abundance vector, pre- post-reproductive stages.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/masks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isolate elements of population dynamics models — masks","text":"","code":"reproduction(matrix, dims = NULL)  survival(matrix, dims = NULL)  transition(matrix, dims = NULL)  all_cells(matrix, dims = NULL)  all_classes(matrix, dims = NULL)  combine(...)"},{"path":"https://aae-stats.github.io/aae.pop/reference/masks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isolate elements of population dynamics models — masks","text":"matrix population dynamics matrix particular mask required. used determine mask dimensions, can matrix appropriate dimensions dims numeric value vector identifying subsets cells include given mask ... set masks masking functions combined single mask one combine methods","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/masks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Isolate elements of population dynamics models — masks","text":"mask object used define cells affected   process included dynamics","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/masks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isolate elements of population dynamics models — masks","text":"","code":"# define a population nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # pull out reproductive elements reproduction(popmat) #>       [,1]  [,2]  [,3]  [,4]  [,5] #> [1,] FALSE  TRUE  TRUE  TRUE  TRUE #> [2,] FALSE FALSE FALSE FALSE FALSE #> [3,] FALSE FALSE FALSE FALSE FALSE #> [4,] FALSE FALSE FALSE FALSE FALSE #> [5,] FALSE FALSE FALSE FALSE FALSE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\"   # what if only 4 and 5 year olds reproduce? reproduction(popmat, dims = 4:5) #>       [,1]  [,2]  [,3]  [,4]  [,5] #> [1,] FALSE FALSE FALSE  TRUE  TRUE #> [2,] FALSE FALSE FALSE FALSE FALSE #> [3,] FALSE FALSE FALSE FALSE FALSE #> [4,] FALSE FALSE FALSE FALSE FALSE #> [5,] FALSE FALSE FALSE FALSE FALSE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\"   # define survival elements survival(popmat) #>       [,1]  [,2]  [,3]  [,4]  [,5] #> [1,]  TRUE FALSE FALSE FALSE FALSE #> [2,] FALSE  TRUE FALSE FALSE FALSE #> [3,] FALSE FALSE  TRUE FALSE FALSE #> [4,] FALSE FALSE FALSE  TRUE FALSE #> [5,] FALSE FALSE FALSE FALSE  TRUE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\"   # what if 1 and 2 year olds always transition? survival(popmat, dims = 3:5) #>       [,1]  [,2]  [,3]  [,4]  [,5] #> [1,] FALSE FALSE FALSE FALSE FALSE #> [2,] FALSE FALSE FALSE FALSE FALSE #> [3,] FALSE FALSE  TRUE FALSE FALSE #> [4,] FALSE FALSE FALSE  TRUE FALSE #> [5,] FALSE FALSE FALSE FALSE  TRUE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\"   # and transitions transition(popmat) #>       [,1]  [,2]  [,3]  [,4]  [,5] #> [1,] FALSE FALSE FALSE FALSE FALSE #> [2,]  TRUE FALSE FALSE FALSE FALSE #> [3,] FALSE  TRUE FALSE FALSE FALSE #> [4,] FALSE FALSE  TRUE FALSE FALSE #> [5,] FALSE FALSE FALSE  TRUE FALSE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\"   # combine transitions and reproduction of 4 and 5 year olds combine(reproduction(popmat, dims = 4:5), transition(popmat)) #>       [,1]  [,2]  [,3]  [,4]  [,5] #> [1,] FALSE FALSE FALSE  TRUE  TRUE #> [2,]  TRUE FALSE FALSE FALSE FALSE #> [3,] FALSE  TRUE FALSE FALSE FALSE #> [4,] FALSE FALSE  TRUE FALSE FALSE #> [5,] FALSE FALSE FALSE  TRUE FALSE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\"   # can also mask the population vector in this way # pull out all classes all_classes(popmat) #>      [,1] #> [1,] TRUE #> [2,] TRUE #> [3,] TRUE #> [4,] TRUE #> [5,] TRUE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\"   # and just 3-5 year olds all_classes(popmat, dims = 3:5) #>       [,1] #> [1,] FALSE #> [2,] FALSE #> [3,]  TRUE #> [4,]  TRUE #> [5,]  TRUE #> attr(,\"class\") #> [1] \"mask\"   \"matrix\" \"array\""},{"path":"https://aae-stats.github.io/aae.pop/reference/metapopulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a metapopulation dynamics object — metapopulation","title":"Create a metapopulation dynamics object — metapopulation","text":"Define population dynamics multiple populations   single species linked dispersal (metapopulation).","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/metapopulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a metapopulation dynamics object — metapopulation","text":"","code":"metapopulation(structure, dynamics, dispersal)  is.metapopulation(x)"},{"path":"https://aae-stats.github.io/aae.pop/reference/metapopulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a metapopulation dynamics object — metapopulation","text":"structure binary logical matrix denoting dispersal links populations. Columns move rows, 1 TRUE cell (, b) denotes movement population b population dynamics dynamics object list dynamics objects one element population (column/row structure). single dynamics object provided, recycled required populations dispersal object created dispersal. dispersal objects describe movements populations can include class-specific movements density-dependent movements. dispersal objects must list one element link structure. links interpreted column-major order, dispersal objects must ordered links column 1, column 2, x object pass .metapopulation","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/metapopulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a metapopulation dynamics object — metapopulation","text":"metapopulation object containing matrix metapopulation   model; use simulate","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/metapopulation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a metapopulation dynamics object — metapopulation","text":"metapopulation function connects multiple   populations known dispersal probabilities, handling   standardisations dispersal probabilities (required)   updating masks functions processes defined within   population. details definition dispersal terms   provided dispersal. Covariates can included metapopulation models. default   behaviour populations share single set covariates,   covariate associations masks defined separately   population. workaround assumption shared covariates   included examples, . Including covariates dispersal   probabilities requires covariate associations masks defined   combined metapopulation model. approach possible   currently untested.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/metapopulation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a metapopulation dynamics object — metapopulation","text":"","code":"# define some populations, all with identical vital rates nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- lapply(   1:3,   function(i) dynamics(popmat) )  # define metapopulation structure with populations #   1 and 3 dispersing into population 2 pop_structure <- matrix(0, nrow = 3, ncol = 3) pop_structure[1, 2] <- 1 pop_structure[3, 2] <- 1  # define dispersal between populations dispersal_matrix <- matrix(0, nrow = nclass, ncol = nclass) dispersal_matrix[survival(dispersal_matrix, dims = 20:25)] <- 0.2 pop_dispersal1 <- dispersal(dispersal_matrix, proportion = TRUE) pop_dispersal2 <- dispersal(dispersal_matrix, proportion = FALSE) pop_dispersal <- list(pop_dispersal1, pop_dispersal2)  # create metapopulation object metapop <- metapopulation(pop_structure, dyn, pop_dispersal)  # simulate without covariates sims <- simulate(metapop, nsim = 2)  # simulate with shared covariates # define a covariates function covar_fn <- function(mat, x) {   mat * (1 / (1 + exp(-0.5 * (x + 10)))) }  # and some covariates xsim <- matrix(rnorm(20), ncol = 1)  # update the population dynamics objects with covariates dyn <- lapply(   dyn,   update,   covariates(masks = transition(dyn[[1]]$matrix), funs = covar_fn) )  # (re)create metapopulation object metapop <- metapopulation(pop_structure, dyn, pop_dispersal) sims <- simulate(   metapop,   nsim = 2,   args = list(covariates = format_covariates(xsim)) )  # simulate with separate covariates #  (requires re-definition of covariate functions) new_fn <- function(i) {   force(i)   function(mat, x) {     mat * (1 / (1 + exp(-0.5 * (x[i] + 10))))   } } new_fn <- lapply(   1:3,   new_fn )  # update the population dynamics objects with covariates dyn <- lapply(   dyn,   update,   covariates(masks = transition(dyn[[1]]$matrix), funs = covar_fn) )  # (re)create metapopulation object metapop <- metapopulation(pop_structure, dyn, pop_dispersal)  # and simulate with one column of predictors for each population xsim <- matrix(rnorm(60), ncol = 3) sims <- simulate(   metapop,   nsim = 2,   args = list(covariates = format_covariates(xsim)) ) #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length #> Warning: longer object length is not a multiple of shorter object length"},{"path":"https://aae-stats.github.io/aae.pop/reference/multispecies.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a population dynamics object with multiple species — multispecies","title":"Create a population dynamics object with multiple species — multispecies","text":"Define population dynamics multiple species   set single-species dynamics objects   defined pairwise interactions.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/multispecies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a population dynamics object with multiple species — multispecies","text":"","code":"multispecies(...)  is.multispecies(x)  is.interaction(x)"},{"path":"https://aae-stats.github.io/aae.pop/reference/multispecies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a population dynamics object with multiple species — multispecies","text":"... pairwise_interaction objects defining set pairwise interactions species x object pass .multispecies","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/multispecies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a population dynamics object with multiple species — multispecies","text":"multispecies object containing multispecies matrix   population model; use simulate","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/multispecies.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a population dynamics object with multiple species — multispecies","text":"","code":"# define population matrices for three species sp1_mat <- rbind(   c(0, 0, 2, 4, 7), # reproduction from 3-5 year olds   c(0.25, 0, 0, 0, 0), # survival from age 1 to 2   c(0, 0.45, 0, 0, 0), # survival from age 2 to 3   c(0, 0, 0.70, 0, 0), # survival from age 3 to 4   c(0, 0, 0, 0.85, 0) # survival from age 4 to 5 ) sp2_mat <- rbind(   c(0, 0, 4), # reproduction from 3 year olds   c(0.25, 0, 0), # survival from age 1 to 2   c(0, 0.45, 0) # survival from age 2 to 3 ) sp3_mat <- rbind(   c(0, 0, 2, 4, 7, 10), # reproduction from 3-6 year olds   c(0.25, 0, 0, 0, 0, 0), # survival from age 1 to 2   c(0, 0.45, 0, 0, 0, 0), # survival from age 2 to 3   c(0, 0, 0.70, 0, 0, 0), # survival from age 3 to 4   c(0, 0, 0, 0.85, 0, 0), # survival from age 4 to 5   c(0, 0, 0, 0, 0.75, 0) # survival from age 5 to 6 )  # define population dynamics objects for each species sp1_dyn <- dynamics(sp1_mat) sp2_dyn <- dynamics(sp2_mat) sp3_dyn <- dynamics(sp3_mat)  # define multispecies interactions as masks/functions # - species 1 influencing transition probabilities of species 3 mask_1v3 <- transition(sp3_mat)  # basic Beverton-Holt function fun_1v3 <- function(x, n) {   # n is the population vector of the source population (sp 1)   x / (1 + x * sum(n[3:5]) / 100) # focus on adults }  # - species 3 influencing reproduction of species 2 mask_3v2 <- reproduction(sp2_mat, dims = 3)  # basic Ricker function fun_3v2 <- function(x, n) {   # n is the population vector of the source population (sp 3)   x * exp(1 - sum(n[1:2]) / 50) / exp(1) # focus on juveniles }  # combine masks and functions into pairwise_interaction objects sp_int1v3 <- pairwise_interaction(sp3_dyn, sp1_dyn, mask_1v3, fun_1v3) sp_int3v2 <- pairwise_interaction(sp2_dyn, sp3_dyn, mask_3v2, fun_3v2)  # compile a multispecies dynamics object multisp_dyn <- multispecies(sp_int1v3, sp_int3v2)  # simulate sims <- simulate(multisp_dyn, nsim = 100)  # and can plot these simulated trajectories for each species plot(sims, which = 1)"},{"path":"https://aae-stats.github.io/aae.pop/reference/pairwise_interaction.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify interactions between two species — pairwise_interaction","title":"Specify interactions between two species — pairwise_interaction","text":"Define population dynamics multiple species   set single-species dynamics objects   defined pairwise interactions.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/pairwise_interaction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify interactions between two species — pairwise_interaction","text":"","code":"pairwise_interaction(target, source, masks, funs)"},{"path":"https://aae-stats.github.io/aae.pop/reference/pairwise_interaction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify interactions between two species — pairwise_interaction","text":"target population whose vital rates affected pairwise interaction source population whose abundances affect vital rates target masks masks defining vital rates influenced function funs functions take vital rates abundances source population inputs return scaled vital rates","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/pairwise_interaction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify interactions between two species — pairwise_interaction","text":"pairwise_interaction object specifying links   species; use multispecies","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/pr_extinct.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate (quasi-)extinction risk for a simulate object — pr_extinct","title":"Calculate (quasi-)extinction risk for a simulate object — pr_extinct","text":"Calculate (quasi-)extinction risk simulate   object","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/pr_extinct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate (quasi-)extinction risk for a simulate object — pr_extinct","text":"","code":"pr_extinct(sims, threshold = 0, subset = NULL, times = NULL)"},{"path":"https://aae-stats.github.io/aae.pop/reference/pr_extinct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate (quasi-)extinction risk for a simulate object — pr_extinct","text":"sims object returned simulate threshold integer numeric denoting threshold population size population considered functionally extinct. Defaults 0 subset integer vector denoting population classes include calculation population abundance. Defaults classes times integer vector specifying generations include calculation extinction risk. Defaults simulated generations","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/pr_extinct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate (quasi-)extinction risk for a simulate object — pr_extinct","text":"single numeric value representing probability population   decline threshold size","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/pr_extinct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate (quasi-)extinction risk for a simulate object — pr_extinct","text":"Quasi-extinction risk probability decline   specified abundance threshold. probability   extracted simulate object   proportion replicate trajectories fall   threshold time step within set period. Abundances   can specified population classes subset   classes.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/pr_extinct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate (quasi-)extinction risk for a simulate object — pr_extinct","text":"","code":"# define a basic population nstage <- 5 popmat <- matrix(0, nrow = nstage, ncol = nstage) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # simulate with the default updater sims <- simulate(dyn, nsim = 1000)  # calculate quasi-extinction risk at a threshold population size #   of 100 individuals pr_extinct(sims, threshold = 100) #> [1] 1  # repeat previous but focused on 4 and 5 year olds only pr_extinct(sims, threshold = 100, subset = 4:5) #> [1] 1  # repeat previous but ignore first 10 years pr_extinct(sims, threshold = 100, times = 11:51) #> [1] 1"},{"path":"https://aae-stats.github.io/aae.pop/reference/replicated_covariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify replicate-specific covariate dependence in models of population dynamics — replicated_covariates","title":"Specify replicate-specific covariate dependence in models of population dynamics — replicated_covariates","text":"Specify relationship vector matrix covariates   vital rates, different covariate value replicate   (.e., value nsim simulate)","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/replicated_covariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify replicate-specific covariate dependence in models of population dynamics — replicated_covariates","text":"","code":"replicated_covariates(masks, funs)"},{"path":"https://aae-stats.github.io/aae.pop/reference/replicated_covariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify replicate-specific covariate dependence in models of population dynamics — replicated_covariates","text":"masks logical matrix vector (list ) defining cells affected funs. See Details masks funs function list functions one element element masks. See Details","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/replicated_covariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify replicate-specific covariate dependence in models of population dynamics — replicated_covariates","text":"replicated_covariates object specifying replicate-specific   covariate effects matrix population model; use   dynamics","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/replicated_covariates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify replicate-specific covariate dependence in models of population dynamics — replicated_covariates","text":"Masks must dimension population   dynamics matrix specify cells influenced covariates   according funs. Additional details masks   provided masks. Functions must take least one argument, vector matrix   representing masked elements population dynamics   matrix. Incorporating covariate values requires second   argument. Functions must return vector matrix   dimensions input, modified reflect   effects covariates vital rates. Additional arguments functions supported can   passed simulate args   argument. format_covariates helper function   takes covariates auxiliary values inputs   returns correctly formatted list can passed   args simulate. replicated_covariates operates identically   covariates except allows different   value covariate applied replicate trajectory.   specification can incorporate complex structures, temporal   dynamics environmental stochasticity correlated uncertainty   vital rates.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/replicated_covariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify replicate-specific covariate dependence in models of population dynamics — replicated_covariates","text":"","code":"# define a population matrix (columns move to rows) nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # can add covariates that influence vital rates #   e.g., a logistic function covars <- replicated_covariates(   masks = transition(popmat),   funs = \\(mat, x) mat * (1 / (1 + exp(-10 * x))) )  # simulate 50 random covariate values for each replicate (each #   value of nsim, set to 100 below) xvals <- matrix(runif(50 * 100), ncol = 100)  # update the dynamics object and simulate from it. #   Note that ntime is now captured in the 50 values #   of xvals, assuming we pass xvals as an argument #   to the covariates functions dyn <- update(dyn, covars) sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   args = list(     replicated_covariates = format_covariates(xvals)   ) )  # and can plot these simulated trajectories plot(sims)"},{"path":"https://aae-stats.github.io/aae.pop/reference/risk_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate (quasi-)extinction risk at multiple thresholds for a simulate object — risk_curve","title":"Calculate (quasi-)extinction risk at multiple thresholds for a simulate object — risk_curve","text":"Calculate (quasi-)extinction risk multiple thresholds   simulate object","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/risk_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate (quasi-)extinction risk at multiple thresholds for a simulate object — risk_curve","text":"","code":"risk_curve(sims, threshold = NULL, subset = NULL, times = NULL, n = 100)"},{"path":"https://aae-stats.github.io/aae.pop/reference/risk_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate (quasi-)extinction risk at multiple thresholds for a simulate object — risk_curve","text":"sims object returned simulate threshold integer numeric vector denoting set threshold population sizes used define risk curve. Defaults n evenly spaced values 0 maximum observed abundance subset integer vector denoting population classes include calculation population abundance. Defaults classes times integer vector specifying generations include calculation extinction risk. Defaults simulated generations n integer specifying number threshold values use default case threshold specified. Defaults 100","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/risk_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate (quasi-)extinction risk at multiple thresholds for a simulate object — risk_curve","text":"named vector containing threshold values (names)   probability population fall threshold values","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/risk_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate (quasi-)extinction risk at multiple thresholds for a simulate object — risk_curve","text":"Risk curves represent pr_extinct multiple   threshold population sizes simultaneously. gives expression   risk population declines range values. Risk curves   extracted simulate object   proportion replicate trajectories fall   threshold value time step within set period. Abundances   can specified population classes subset   classes. get_cdf function much faster way generate   risk curves almost use cases. exception   threshold argument used specify threshold values   evenly spaced.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/risk_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate (quasi-)extinction risk at multiple thresholds for a simulate object — risk_curve","text":"","code":"# define a basic population nstage <- 5 popmat <- matrix(0, nrow = nstage, ncol = nstage) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # simulate with the default updater sims <- simulate(dyn, nsim = 100)  # calculate risk curve risk_curve(sims, n = 10) #>   0  55 109 164 218 273 327 382 436 491  #>   0   1   1   1   1   1   1   1   1   1"},{"path":"https://aae-stats.github.io/aae.pop/reference/rng.html","id":null,"dir":"Reference","previous_headings":"","what":"Random number generators not available in existing R packages — rng","title":"Random number generators not available in existing R packages — rng","text":"Draw random numbers unusual distributions,   unit non-negative real line known   means standard deviations.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/rng.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random number generators not available in existing R packages — rng","text":"","code":"rmultiunit(   n,   mean,   sd,   Sigma = NULL,   Omega = NULL,   perfect_correlation = FALSE )  rmultiunit_from_real(   n,   mean_real,   sd_real = NULL,   Sigma_chol = NULL,   perfect_correlation = FALSE )  runit_from_real(n, mean_real, sd_real)  runit(n, mean, sd)  unit_to_real(unit_mean, unit_sd)"},{"path":"https://aae-stats.github.io/aae.pop/reference/rng.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random number generators not available in existing R packages — rng","text":"n number random draws simulate. draw vector values length equal length(mean) length(sd) resulting output n rows length(mean) columns mean vector mean values unit scale sd vector positive standard deviations Sigma optional covariance matrix dimensions length(mean) length(mean) defining covariances pair values mean. Note correlation structure retained Sigma, standard deviations still required Omega optional correlation matrix dimensions length(mean) length(mean) defining correlations pair values mean perfect_correlation logical, TRUE Sigma Omega NULL, values replicate (row) perfectly correlated known mean standard deviation. FALSE, values replicate completely uncorrelated mean_real vector mean values converted real-line equivalents sd_real vector standard deviations converted real-line equivalents Sigma_chol Cholesky decomposition covariance matrix converted real-line equivalent unit_mean vector mean values unit interval unit_sd vector standard deviations unit interval","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/rng.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random number generators not available in existing R packages — rng","text":"vector matrix random draws r*unit   set functions","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/rng.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random number generators not available in existing R packages — rng","text":"r*unit family functions support simulation values   unit interval based known mean, sd, correlation   structure. runit runit_from_real vectorised   univariate functions, rmultiunit   rmultiunit_from_real multivariate versions   functions. runit rmultiunit provide   simulated values unit line specified means, standard   deviations, correlation/covariance structure (case   rmultiunit). *_from_real versions functions helpers   use pre-transformed estimates parameters real   line, calculated unit_to_real. functions   exported unit_to_real, called within   runit rmultiunit, slow. Separating   separate step allows less frequent calculations   transformation using function dynamic versions   args simulate. unit_to_real converts means standard deviations   values unit line equivalent   values real line. use different versions functions   illustrated Macquarie perch example package   [website](https://aae-stats.github.io/aae.pop/).","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/rng.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random number generators not available in existing R packages — rng","text":"","code":"# rmultiunit generates multivariate draws constrained to #   the unit interval, with known mean, standard deviation, #   and (optionally) covariance/correlation structure rmultiunit(n = 10, mean = c(0.25, 0.5, 0.75), sd = c(0.1, 0.4, 0.25)) #>            [,1]       [,2]      [,3] #>  [1,] 0.1575853 0.01761254 0.9445593 #>  [2,] 0.4276270 0.52709738 0.9603336 #>  [3,] 0.3186457 0.62405500 0.8450844 #>  [4,] 0.2722320 0.54031791 0.9504178 #>  [5,] 0.3991552 0.54087440 0.9689834 #>  [6,] 0.1838829 0.01500115 0.9838706 #>  [7,] 0.2273197 0.39881780 0.9967373 #>  [8,] 0.3448995 0.99999743 0.8872065 #>  [9,] 0.3162860 0.52977018 0.8180310 #> [10,] 0.2871536 0.96621961 0.8767448  # add in a correlation structure omega_set <- cbind(   c(1, 0.25, 0.01),   c(0.25, 1, 0.5),   c(0.01, 0.5, 1) ) rmultiunit(   n = 10,   mean = c(0.25, 0.5, 0.75),   sd = c(0.1, 0.4, 0.25),   Omega = omega_set ) #> Warning: NaNs produced #> Warning: NaNs produced #>            [,1]         [,2]       [,3] #>  [1,] 0.1390801 8.584424e-01 0.88133202 #>  [2,] 0.2980836 9.850293e-01 0.92972847 #>  [3,] 0.2346260 9.989593e-01 0.99084645 #>  [4,] 0.1048095 2.155613e-04 0.09527154 #>  [5,] 0.3132903 9.935197e-01 0.99884698 #>  [6,] 0.2815907 1.366113e-06 0.13019641 #>  [7,] 0.4289172 9.999996e-01 0.97808043 #>  [8,] 0.1296939 6.571871e-01 0.53406620 #>  [9,] 0.2944634 5.203511e-04 0.36741513 #> [10,] 0.2610939 3.688165e-02 0.93892145"},{"path":"https://aae-stats.github.io/aae.pop/reference/simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate single or multispecies population dynamics in R — simulate","title":"Simulate single or multispecies population dynamics in R — simulate","text":"Simulate population dynamics one   species defined dynamics objects.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate single or multispecies population dynamics in R — simulate","text":"","code":"# S3 method for class 'dynamics' simulate(   object,   nsim = 1,   seed = NULL,   ...,   init = NULL,   options = list(),   args = list(),   .future = FALSE )  is.simulation(x)  is.simulation_list(x)"},{"path":"https://aae-stats.github.io/aae.pop/reference/simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate single or multispecies population dynamics in R — simulate","text":"object dynamics object created dynamics subsequent call multispecies metapopulation. Alternatively, object can output call simulate case summary nsim number replicate simulations (default = 1) seed optional seed used prior initialisation simulation give reproducible results ... ignored; included consistency simulate generic method init array initial conditions one row per replicate one column per population stage. obj created multispecies, initial conditions can provided list array one element slice per species, matrix, case species assumed share initial conditions. Defaults NULL, case initial conditions generated randomly according options()$aae.pop_initialisation options named list simulation options. Currently accepted   values : - ntime number time steps simulate, ignored obj       includes covariates (default = 50) - keep_slices logical defining whether keep intermediate       population abundances (FALSE) return final       time slice - tidy_abundances function handle predicted abundance data       may non-integer. Defaults identity; suggested       alternatives floor, round, ceiling - initialise_args list arguments passed function       used initialise abundance trajectories. used       init = NULL. Defaults options()$aae.pop_lambda,       specifies lambda Poisson random draws. default       initialisation function defined       options()$aae.pop_initialisation. - update function update abundances one time       step next. Defaults options()$aae.pop_update. args named list lists passing arguments processes defined   object, including interaction   multispecies objects. Lists (one per process)   can contain mix static, dynamic, function arguments.   Dynamic arguments must lists one element per time step.   Function arguments must functions calculate arguments   dynamically generation based population dynamics   object, population abundances, time step generation.   classes (e.g., single values, matrices, data frames)   treated static arguments. Covariates contained numeric   vectors, matrices, data frames can formatted dynamic   arguments format_covariates function. args multispecies objects must one   element per species (defaults expand automatically provided) .future flag determine whether future package used manage updates multispecies models (embarrassingly parallel problem) x object pass .simulation .simulation.list","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate single or multispecies population dynamics in R — simulate","text":"simulation object containing replicate simulations   matrix population model. plot subset methods   defined simulation objects","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate single or multispecies population dynamics in R — simulate","text":"","code":"# define a population matrix (columns move to rows) nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # can extract standard population matrix summary stats lambda <- Re(eigen(popmat)$values[1])  # define a dynamics object dyn <- dynamics(popmat)  # simulate from this (50 time steps, 100 replicates) sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))  # plot the simulated trajectories plot(sims)   # add some density dependence dd <- density_dependence(   masks = reproduction(popmat, dims = 4:5),   funs = ricker(1000) )  # update the dynamics object dyn <- update(dyn, dd)  # simulate again sims <- simulate(dyn, nsim = 100, options = list(ntime = 50))  # and plot plot(sims)   # what if we want to add initial conditions? sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   options = list(ntime = 50), )  # and plot again plot(sims)   # note that there is only one trajectory now because #   this simulation is deterministic. # # let's change that by adding some environmental stochasticity envstoch <- environmental_stochasticity(   masks = list(     reproduction(popmat, dims = 4:5),     transition(popmat)   ),   funs = list(     \\(x) rpois(n = length(x), lambda = x),     \\(x) runif(n = length(x), min = 0.9 * x, max = pmin(1.1 * x, 1))   ) )  # update the dynamics object and simulate from it dyn <- update(dyn, envstoch) sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   options = list(ntime = 50), )  # can also add covariates that influence vital rates #   e.g., a logistic function covars <- covariates(   masks = transition(popmat),   funs = \\(mat, x) mat * (1 / (1 + exp(-10 * x))) )  # simulate 50 random covariate values xvals <- matrix(runif(50), ncol = 1)  # update the dynamics object and simulate from it. #   Note that ntime is now captured in the 50 values #   of xvals, assuming we pass xvals as an argument #   to the covariates functions dyn <- update(dyn, covars) sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   args = list(covariates = format_covariates(xvals)) )  # a simple way to add demographic stochasticity is to change #   the \"updater\" that converts the population at time t #   to its value at time t + 1. The default in aae.pop #   uses matrix multiplication of the vital rates matrix #   and current population. A simple tweak is to update #   with binomial draws. Note that this also requires a #   change to the \"tidy_abundances\" option so that population #   abundances are always integer values. sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   options = list(     update = update_binomial_leslie,     tidy_abundances = floor   ),   args = list(covariates = format_covariates(xvals)) )  # and can plot these again plot(sims)"},{"path":"https://aae-stats.github.io/aae.pop/reference/stochasticity.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify environmental and demographic stochasticity in models of population dynamics — stochasticity","title":"Specify environmental and demographic stochasticity in models of population dynamics — stochasticity","text":"Specify environmental stochasticity (random variation   vital rates) demographic stochasticity (random variation   population outcomes).","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/stochasticity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify environmental and demographic stochasticity in models of population dynamics — stochasticity","text":"","code":"environmental_stochasticity(masks, funs)  demographic_stochasticity(masks, funs)"},{"path":"https://aae-stats.github.io/aae.pop/reference/stochasticity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify environmental and demographic stochasticity in models of population dynamics — stochasticity","text":"masks logical matrix vector (list ) defining cells affected funs. See Details masks funs function list functions one element element masks. See Details","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/stochasticity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify environmental and demographic stochasticity in models of population dynamics — stochasticity","text":"environmental_stochasticity   demographic_stochasticity object specifying way   stochasticity included matrix population model;   use dynamics","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/stochasticity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify environmental and demographic stochasticity in models of population dynamics — stochasticity","text":"Masks must dimension population   dynamics matrix (case environmental stochasticity)   one element class (case demographic   stochasticity). Masks specify cells influenced stochasticity   according funs. Additional details masks provided   masks. Functions must least one argument, population   dynamics matrix environmental   stochasticity vector population abundances   demographic stochasticity. Functions must return   output dimensions input,   modified reflect effects stochasticity   vital rates population abundances. Additional arguments functions supported can   passed simulate args,   args.dyn, args.fn arguments.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/stochasticity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify environmental and demographic stochasticity in models of population dynamics — stochasticity","text":"","code":"# define a population matrix (columns move to rows) nclass <- 5 popmat <- matrix(0, nrow = nclass, ncol = nclass) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # note that there is only one trajectory now because #   this simulation is deterministic. # # let's change that by adding some environmental stochasticity envstoch <- environmental_stochasticity(   masks = list(     reproduction(popmat, dims = 4:5),     transition(popmat)   ),   funs = list(     \\(x) rpois(n = length(x), lambda = x),     \\(x) runif(n = length(x), min = 0.9 * x, max = pmin(1.1 * x, 1))   ) )  # update the dynamics object and simulate from it dyn <- update(dyn, envstoch) sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   options = list(ntime = 50), )  # a simple way to add demographic stochasticity is to change #   the \"updater\" that converts the population at time t #   to its value at time t + 1. The default in aae.pop #   uses matrix multiplication of the vital rates matrix #   and current population. A simple tweak is to update #   with binomial draws. Note that this also requires a #   change to the \"tidy_abundances\" option so that population #   abundances are always integer values. sims <- simulate(   dyn,   init = c(50, 20, 10, 10, 5),   nsim = 100,   options = list(     update = update_binomial_leslie,     tidy_abundances = floor   ) )"},{"path":"https://aae-stats.github.io/aae.pop/reference/updaters.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions for a single time-step update — updaters","title":"Functions for a single time-step update — updaters","text":"Define population abundances updated   one time step next. Functions can take form   vectorised across replicates limited situations.","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/updaters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions for a single time-step update — updaters","text":"","code":"update_crossprod(pop, mat)  update_binomial_leslie(pop, mat)  update_multinomial(pop, mat)"},{"path":"https://aae-stats.github.io/aae.pop/reference/updaters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions for a single time-step update — updaters","text":"pop current state population mat matrix vital rates used update population state","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/updaters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions for a single time-step update — updaters","text":"matrix containing population abundances stage   matrix population model. Contains one row replicate population   trajectory one column population stage","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/updaters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions for a single time-step update — updaters","text":"Updaters can changed options   argument simulate can also changed   globally R session changing global option ,   e.g., options(aae.pop_update = update_binomial_leslie) update_crossprod updates abundances direct   matrix multiplication include form demographic   stochasticity. fastest update option vectorise   across replicates population matrix expanded   environmental_stochasticity   density_dependence. update_binomial_leslie updates abundances   direct RNG draw combines update demographic   stochasticity, assuming Leslie matrix. update_multinomial updates abundances   direct RNG draw combines update demographic stochasticity,   allowing general matrix forms (slower   update_binomial_leslie).","code":""},{"path":"https://aae-stats.github.io/aae.pop/reference/updaters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions for a single time-step update — updaters","text":"","code":"# define a basic population nstage <- 5 popmat <- matrix(0, nrow = nstage, ncol = nstage) popmat[reproduction(popmat, dims = 4:5)] <- c(10, 20) popmat[transition(popmat)] <- c(0.25, 0.3, 0.5, 0.65)  # define a dynamics object dyn <- dynamics(popmat)  # simulate with the default updater sims <- simulate(dyn)  # simulate with a multinomial updater sims <- simulate(dyn, options = list(update = update_multinomial))"},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"features-0-2-0","dir":"Changelog","previous_headings":"","what":"Features","title":"aae.pop 0.2.0","text":"consistent handling processes model types isolate extension packages remove vignettes depend ","code":""},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"aae.pop 0.2.0","text":"address checks pre-CRAN submission","code":""},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"features-0-1-2","dir":"Changelog","previous_headings":"","what":"Features","title":"aae.pop 0.1.2","text":"add_remove_pre add_remove_post added handle removals additions population vector prior following update step plot function dynamics objects updated allow custom labels","code":""},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"fixes-0-1-2","dir":"Changelog","previous_headings":"","what":"Fixes","title":"aae.pop 0.1.2","text":"Increase test coverage Update labelling plots dynamic objects override defaults custom labels supplied Update labelling plots dynamic objects classify reproductive first stages reproduction, survival Change fecundity reproduction DiagrammeR plots dynamics objects Change reproduction mask allow first stage reproduce, default excludes first stage (2:ncol(mat)) Change plot.dynamics cycles first stage labelled reproduction default. argument cycles_first can set \"survival\" revert original behaviour","code":""},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"features-0-1-1","dir":"Changelog","previous_headings":"","what":"Features","title":"aae.pop 0.1.1","text":"replicated_covariates process class added handle covariates applied separately replicate trajectory","code":""},{"path":[]},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"features-0-1-0","dir":"Changelog","previous_headings":"","what":"Features","title":"aae.pop 0.1.0","text":"get_cdf, get_pdf, emps, exps methods added summarise simulated population trajectories:","code":""},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"fixes-0-1-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"aae.pop 0.1.0","text":"replace Travis CI GitHub Actions","code":""},{"path":"https://aae-stats.github.io/aae.pop/news/index.html","id":"api-changes-0-1-0","dir":"Changelog","previous_headings":"","what":"API changes","title":"aae.pop 0.1.0","text":"removed deprecated args.dyn args.fn arguments simulate removed inference methods, now included aae.pop.inference package","code":""}]
