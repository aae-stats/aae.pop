---
title: "Comparing scenarios with population models"
author: "Jian Yen"
date: "13/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(aae.pop)
```

## Background

A common application of population models is the comparison of scenarios based on population outcomes. Examples include predicting population trajectories under different scenarios of climate change, comparing or ranking competing management scenarios, and predicting the consequences of different ecological hypotheses. This example uses a simplified model of population dyanamics to demonstrate the comparison of multiple scenarios, as well as several methods to speed computation when simulating many scenarios.

## A simple population model

This example will focus on a simplified model of population dynamics for tractability. The example will consider four distinct populations (i.e., separate populations, not a metapopulation) of the same species with identical average vital rates in all populations. This species is assumed to have vital rates and demographic processes similar to the example species in the [Including processes](including_processes.html) vignette:

```{r}
# the population matrix
popmat <- rbind(
  c(0,    0,    10,   15,    20),  # reproduction from 3-5 year olds
  c(0.50, 0,    0,    0,     0),   # survival from age 1 to 2
  c(0,    0.65, 0,    0,     0),   # survival from age 2 to 3
  c(0,    0,    0.85, 0,     0),   # survival from age 3 to 4
  c(0,    0,    0,    0.9,   0)    # survival from age 4 to 5
)

# add some demographic stochasticity
demostoch_mask <- all_classes(popmat) # affects all classes
demostoch_fn <- function(x) {
  rpois(length(x), lambda = x)
}
demostoch <- demographic_stochasticity(
  masks = demostoch_mask,
  funs = demostoch_fn
)

# and some environmental stochasticity
reproduction_mask <- reproduction(popmat, dims = 3:5) # only ages 3-5 reproduce
reproduction_fn <- function(x) {
  rpois(length(x), lambda = x)
}
transition_mask <- transition(popmat) # all classes this time
transition_fn <- function(x) {
  
  # add a random deviation to x
  deviation <- runif(length(x), min = -0.1, max = 0.1)
  x <- x + deviation
  
  # make sure the result isn't negative or greater than 1
  x[x < 0] <- 0
  x[x > 1] <- 1
  
  # return the value
  x
  
}
envstoch <- environmental_stochasticity(
  masks = list(reproduction_mask, transition_mask),
  funs = list(reproduction_fn, transition_fn)
)

# specify a Ricker model for density dependence
dd <- density_dependence(
  masks = reproduction(popmat, dims = 3:5), # only adults reproduce
  funs = ricker(k = 40, exclude = 1:2)      # set k based on adult abundances
)
```

Some more-complex processes are required to simulate the scenarios below. One of these is the consideration of fishing regulations that change through time, which might be captured with a `density_dependence_n` function where the proportion or number of individuals removed changes through time:

```{r}
# specify a function to remove a set number of adults in any given year,
#   with an argument that can be changed through time to incorporate
#   changing scenarios
removals_fn <- function(n, remove) {
  
  # add some stochasticity in the number of removals
  remove <- rpois(1, lambda = remove)
  
  # check that there are enough individuals to remove,
  #   only remove up to sum(n) individuals
  if (remove > sum(n))
    remove <- sum(n)
  
  # work out which age classes to remove, sampled
  #   randomly up to the total available in each
  #   age class
  n_available <- rep(3:5, times = n)
  removal_idx <- sample.int(
    length(n_available), size = remove, replace = FALSE
  )
  
  # expand this into a vector of removals by age class
  remove <- table(n_available[removal_idx])
  remove_expanded <- rep(0, 3)
  names(remove_expanded) <- as.character(3:5)
  remove_expanded[names(remove)] <- remove

  # and return updated abundances
  n - remove_expanded
  
}

# collate this into a single density_dependence_n object, 
#   focusing on adults
dd_n <- density_dependence_n(
  masks = all_classes(popmat, dims = 3:5), # want to focus on adults
  funs = removals_fn
)
```

The scenarios below also consider habitat restoration at multiple sites. The effects of habitat restoration can be captured with a `covariates` process that alters vital rates based on the current habitat extent:

```{r}
# effects of habitat condition on reproduction
#    reductions up to 10 % if habitat is non-existent,
#    minimal reductions if habitat reaches 50 % of 
#    its maximum extent
reproduction_effects <- function(mat, x, alpha = 0.1, beta = 4, ...) {

  # define a nonlinear effect of habitat
  scale_factor <- 1 / (1 + alpha * exp(- beta * x))

  # return re-scaled survival values
  mat * scale_factor

}

# effects of habitat condition on survival
#    minimal reductions unless habitat falls
#    below 30 % of its expected extent, up to
#    a 5 % reduction with non-existent habitat
survival_effects <- function(mat, x, alpha = 0.05, beta = 10, ...) {

  # define a nonlinear effect of habitat
  scale_factor <- 1 / (1 + alpha * exp(- beta * x))

  # return re-scaled survival values
  mat * scale_factor

}

# define masks
covar_masks <- list(
  reproduction(popmat),
  transition(popmat)
)

# link functions to masks
covar_funs <- list(
  reproduction_effects,
  survival_effects
)

# collate into a single object
covars <- covariates(
  masks = covar_masks,
  funs = covar_funs
)
```

## Defining scenarios

This example considers a set of scenarios based on combinations of four generalised management actions implemented across four populations (four distinct locations). The actions are:

- increase habitat extent by 40 % at the location with the least habitat

- increase habitat extent by 15 % each at the two locations with the least habitat

- regulate and enforce a complete ban on fishing at two locations

- reduce fishing pressure through regulation and partial enforcement at all locations

The first and second actions are alternatives to one another, as are the third and fourth actions. Therefore, there are 9 possible combinations of actions are:

- habitat restoration at one location, fishing regulation at two locations

- habitat restoration at one location, fishing regulation at all locations

- habitat restoration at two locations, fishing regulation at two locations

- habitat restoration at two locations, fishing regulation at all locations

- habitat restoration at one location, no fishing regulation

- habitat restoration at two locations, no fishing regulation

- no habitat restoration, fishing regulation at two locations

- no habitat restoration, fishing regulation at all locations

- no habitat restoration, no fishing regulation

The four actions are hypothetical but can be assumed to have similar financial costs. Therefore, the purpose of scenario testing in this case is to identify the benefits of different combinations of actions relative to one another and relative to taking no action.

The different actions can be implemented in `aae.pop` through functions that convert actions to sequences of covariates and arguments that influence the `covariates` and `density_dependence_n` processes in `simulate`. For habitat restoration, this function might look like:

```{r}
# function to define habitat extent including restoration effects
restore <- function(n, amount, current, ntime) {
  
  # pull out the worst n sites
  idx <- order(current, decreasing = FALSE)[seq_len(n)]

  # create sequences of habitat extent at all sites
  current <- do.call(
    rbind,
    lapply(seq_len(ntime), function(x) current)
  )
  
  # add habitat over a period of 5 years, up to `amount`
  add <- c(seq(0, amount, length = 5), rep(amount, ntime - 5))

  # update sequences of habitat extent in the worst n sites  
  current[, idx] <- sweep(
    current[, idx, drop = FALSE],
    1,
    add,
    "+"
  )
  
  # return
  current
  
}
```

To incorporate scenarios of fishing regulation simply requires an `args` element for `density_dependence_n` that specifies the average number of fish removed per year. In this case, unregulated fishing is assumed to remove 50 fish per year at a site, with partial regulation reducing this to 25 fish removed per year.

## Simulating many scenarios

There are nine possible combinations of actions (nine management *options*) and four populations. Simulating population dynamics in this case requires at least 36 simulations. This section will demonstrate the simplest way to set up and simulate dynamics for many scenarios. The following section will present several methods to speed up computation in very large cases (e.g., thousands or even millions of scenarios).

### Setting up the model

With 36 simulations, each taking perhaps a few seconds, there is no real need to speed up simulations. In this case, the complexity is in setting up and defining the scenarios and interpreting their outputs. Set up requires simulations for each of the four populations under each of the management actions. The following code does this, using the `calculate_quasi_extinction` function defined in the [Macquarie perch](macperch_example.html) example to summarise population trajectories:

```{r, echo = FALSE}
# calculate proportion of trajectories falling below a given threshold
#   in any time step. By default, all population classes are included
#   but `subset` can be used to select specific classes
calculate_quasi_extinction <- function(popsim, threshold, subset = NULL, include = FALSE) {
  
  # is a subset required?
  if (!is.null(subset))
    popsim <- subset(popsim, subset = subset)
  
  # sum population abundances over all remaining classes
  popsim <- apply(popsim, c(1, 3), sum)
  
  # do we want to include the threshold value in the check?
  if (include)
    threshold <- threshold + 1e-5
  
  # is a trajectory below a threshold?
  threshold_check <- apply(popsim, 1, function(x) x < threshold)
  
  # return proportion below threshold
  #   (mean of binary values is the proportion equal to 1)
  mean(threshold_check)
  
}
```

```{r}
# set up some basic parameters
npop <- 4      # how many populations?
ntime <- 50    # how many years to simulate?
nsim <- 1000   # how many replicates?

# simulate current habitat extent (between 20 % and 60 %)
habitat_extent <- runif(n = npop, min = 0.2, max = 0.6)

# define a population model for each of the four populations
popdyn <- lapply(
  seq_len(npop),
  function(i) dynamics(
    envstoch(popmat),   # alter the matrix slightly for each population
    envstoch,
    demostoch,
    dd,
    dd_n,
    covars
  )
)

# define initial abundances in each population
initial_abundance <- replicate(
  npop, rpois(5, lambda = c(100, 50, 25, 10, 5))
)

# define the habitat restoration actions
habitat <- rbind(
  "restore_none" = c(n = 0, amount = 0),   # no sites restored
  "restore_one" = c(n = 1, amount = 0.40), # one site increased by 40 %
  "restore_two" = c(n = 2, amount = 0.15)  # two sites each increased by 15 %
)

# define the fishing regulation actions
fishing <- rbind(
  "regulate_none" = c(remove = c(50, 50, 50, 50)),  # baseline fishing pressure
  "regulate_two" = c(remove = c(0, 0, 50, 50)),     # complete halt at two sites
  "regulate_all" = c(remove = c(25, 25, 25, 25))    # reduction at all sites
)

# define all combinations of actions
scenarios <- expand.grid(
  habitat = rownames(habitat),
  fishing = rownames(fishing)
)

# loop through each scenario
quasi_ext <- matrix(NA, nrow = nrow(scenarios), ncol = npop)  # empty matrix to store extinction risk estimates
for (i in seq_len(nrow(scenarios))) {
  
  # pull out the relevant actions
  hab_tmp <- habitat[scenarios$habitat[i], ]
  fish_tmp <- fishing[scenarios$fishing[i], ]
  
  # define habitat extent taking into account restoration
  extent_tmp <-restore(
    n = hab_tmp[1],
    amount = hab_tmp[2],
    current = habitat_extent,
    ntime = ntime
  )
  
  # the populations are independent, so can be run simultaneously 
  #   with lapply, mapply, or with a for loop
  sims <- list()
  for (j in seq_along(popdyn)) {
    sims[[j]] <- simulate(
      popdyn[[j]],
      nsim = nsim,
      init = initial_abundance[, j],
      args = list(
        covariates = format_covariates(extent_tmp[, j]),
        density_dependence_n = list(remove = fish_tmp[j])
      )
    )    
  }
  
  # summarise the trajectories
  quasi_ext[i, ] <- sapply(
    sims, 
    calculate_quasi_extinction,
    threshold = 10,     # the quasi-extinction level
    subset = 3:5,       # focus on adults
    include = TRUE      # less than or equal to threshold
  )
  
}
```

The simulation approach demonstrated here is relatively comprehensive, considering every feasible combination of actions and simulating 1000 replicate trajectories for each population under each scenario. Extensions to this might explore additional sources of variation, such as using a range of initial conditions or including variation in other covariates (e.g., weather or climate). In this particular example, the fishing action was also static, with the `regulate_two` action always regulating the same two populations (locations 1 and 2).

### Interpreting the outputs

The quasi-extinction estimates can be interpreted directly for each population under each of the nine scenarios:

```{r, echo = FALSE}
out <- cbind(scenarios, round(quasi_ext, 2))
colnames(out) <- c("habitat", "fishing", paste("population", 1:4, sep = " "))
print(out)
```

These results highlight an interesting pattern. Fishing regulation clearly has a major impact on population trajectories, with a complete ban on fishing reducing extinction risk almost to zero in regulated populations. However, the remaining (unregulated) populations still have relatively high quasi-extinction risks. This highlights a conceptual challenge when results are spread over multiple populations: how much is an individual population worth?

It's possible to dig into this with some additional summary statistics that augment the population-level estimates of quasi-extinction risk:

```{r}
# average quasi-extinction risk
average_risk <- apply(quasi_ext, 1, mean)

# geometric mean quasi-extinction risk
geom_ave_risk <- apply(quasi_ext, 1, function(x) exp(mean(log(x))))

# probability that at least one population becomes (quasi) extinct
one_or_more_ext <- 1 - apply(quasi_ext, 1, function(x) prod(1 - x))
```

Alternatively, the probability of persistence (i.e., avoiding extinction) can often be a useful output:

```{r}
# probability of persistence for all populations under each scenario
pr_persist <- 1 - quasi_ext

# probability that at least one population persists
one_or_more_persist <- 1 - apply(quasi_ext, 1, prod)

# probability that all four populations persist
all_persist <- apply(pr_persist, 1, prod)
```

These outputs give a more-complete picture of the relative risk under each of the nine scenarios:

```{r, echo = FALSE}
out <- cbind(scenarios, average_risk, geom_ave_risk, one_or_more_ext, one_or_more_persist, all_persist)
out[, 3:ncol(out)] <- round(out[, 3:ncol(out)], 2)
colnames(out) <- c("Habitat action", "Fishing action", "Average risk", "Geometric average risk", "Pr(at least one extinct)", "Pr(at least one persist)", "Pr(all persist)")
print(out)
```

These outputs provide a clearer picture of the relative risks of the different scenarios, supporting decisions based on priorities for a single versus multiple populations. In this case, there is little justification for investment in habitat restoration but plenty of reason to invest in regulating fishing. A focus on persistence of a single population doesn't distinguish the two fishing actions (partial or complete ban), yet a focus on maintaining all populations indicates that partial regulation across all locations is likely to be a much more effective strategy, reducing the risk that any one of the populations will become extinct.

Many variants of these summaries exist, such as probabilities that 2 or more populations persist, average extinction risk weighted by a measure of a population's value, or metrics based on expected genetic or functional diversity under each scenarios.

The outputs of this modelling approach might support a recommendation in their own right, or might guide the development of alternative management actions, such as more-nuanced fishing regulations or more extensive habitat restoration scenarios. Alternatively, model outputs might highlight flaws in model construction. For example, if habitat restoration is known to be more effective than indicated by the results above, this might indicate knowledge gaps that limit the current model's applicability.

## Speeding up simulations

### Running in parallel

### Not-so-meta populations

This document is yet to explore one option: running all four populations as a `metapopulation` with no dispersal. Although this method has computational benefits, it requires separate fishing and restoration functions with distinct arguments for each population.
